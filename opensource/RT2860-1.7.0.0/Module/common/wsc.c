/*
 ***************************************************************************
 * Ralink Tech Inc.
 * 4F, No. 2 Technology	5th	Rd.
 * Science-based Industrial	Park
 * Hsin-chu, Taiwan, R.O.C.
 *
 * (c) Copyright 2002-2006, Ralink Technology, Inc.
 *
 * All rights reserved.	Ralink's source	code is	an unpublished work	and	the
 * use of a	copyright notice does not imply	otherwise. This	source code
 * contains	confidential trade secret material of Ralink Tech. Any attemp
 * or participation	in deciphering,	decoding, reverse engineering or in	any
 * way altering	the	source code	is stricitly prohibited, unless	the	prior
 * written consent of Ralink Technology, Inc. is obtained.
 ***************************************************************************

	Module Name:
	wsc.c

	Abstract:

	Revision History:
	Who			When			What
	--------	----------		----------------------------------------------
	Paul Lin	06-08-08		Initial
	Snowpin Lee 06-09-12        Do modifications and Add APIs for AP
	Snowpin Lee 07-04-19        Do modifications and Add APIs for STA
	Snowpin Lee 07-05-17        Do modifications and Add APIs for AP Client
*/
#include    "rt_config.h"
#include    "wsc_tlv.h"
#include <net/iw_handler.h>

#define WSC_UPNP_MSG_TIMEOUT			(150 * HZ)
#define RTMP_WSC_NLMSG_SIGNATURE_LEN	8

#ifndef PF_NOFREEZE
#define PF_NOFREEZE  0
#endif

char WSC_MSG_SIGNATURE[]={"RAWSCMSG"};
static int gWscActionMode;

// General used field
// move Wsc_Uuid_E & Wsc_Uuid_Str definition to rtmp.h (for multiple card)
//UCHAR Wsc_Uuid_E[UUID_LEN_HEX] = {0x0};
//UCHAR Wsc_Uuid_Str[UUID_LEN_STR]= {0x0};

#ifdef CONFIG_AP_SUPPORT
UCHAR	Wsc_Pri_Dev_Type[8] = {0x00, 0x06, 0x00, 0x50, 0xf2, 0x04, 0x00, 0x01};

VOID    WscDelWPARetryTimer(
    IN  PRTMP_ADAPTER pAd);

#ifdef APCLI_SUPPORT
void    WscWriteConfToApCliCfg(
    IN  PRTMP_ADAPTER   pAd,
    IN  MAC_TABLE_ENTRY *pEntry,
    IN  BOOLEAN         bEnrollee);
#endif // APCLI_SUPPORT //
#endif // CONFIG_AP_SUPPORT //

BOOLEAN WscCheckNonce(
	IN	PRTMP_ADAPTER	pAdapter, 
	IN	MLME_QUEUE_ELEM	*Elem,
	IN  BOOLEAN         bFlag,
	IN  PWSC_CTRL       pWscControl);

VOID    WscEapActionDisabled(
    IN  PRTMP_ADAPTER       pAdapter,
    IN  PWSC_CTRL           pWscControl);

VOID    WscGetConfigErrFromNack(
    IN  PRTMP_ADAPTER       pAdapter,
    IN	MLME_QUEUE_ELEM	    *pElem);

INT	    WscSetAuthMode(
	IN	PRTMP_ADAPTER	pAd, 
	IN	PUCHAR			arg);

INT	    WscSetEncrypType(
	IN	PRTMP_ADAPTER	pAd, 
	IN	PUCHAR			arg);

INT write_dat_file_thread (void *data);


/*
	Standard UUID generation procedure. The UUID format generated by this function is base on UUID std. version 1.
	It's a 16 bytes, one-time global unique number. and can show in string format like this:
			550e8400-e29b-41d4-a716-446655440000 
			
	The format of uuid is:
		uuid                        = <time_low> "-"
		                              <time_mid> "-"
		                              <time_high_and_version> "-"
		                              <clock_seq_high_and_reserved>
	    	                          <clock_seq_low> "-"
		                              <node>
		time_low                    = 4*<hex_octet>
		time_mid                    = 2*<hex_octet>
		time_high_and_version       = 2*<hex_octet>
		clock_seq_high_and_reserved = <hex_octet>
		clock_seq_low               = <hex_octet>
		node                        = 6*<hex_octet>
		hex_octet                   = <hex_digit> <hex_digit>
		hex_digit                   = "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
		                              |"a"|"b"|"c"|"d"|"e"|"f"
		                              |"A"|"B"|"C"|"D"|"E"|"F"
	Note:
		Actually, to IOT with JumpStart, we fix the first 10 bytes of UUID string!!!!
*/
INT WscGenerateUUID(RTMP_ADAPTER *pAd, UCHAR *uuidHexStr, UCHAR *uuidAscStr, int apIdx)
{
	
	WSC_UUID_T uuid_t;
	unsigned long long uuid_time;
	int i;
	UINT16 clkSeq;
	
	// Get the current time.
	uuid_time = 2860; //xtime.tv_sec; 	// Well, we fix this to make JumpStart  happy!
	uuid_time *= 10000000;
	uuid_time += 0x01b21dd213814000LL;
	
	uuid_t.timeLow = (UINT32)uuid_time & 0xFFFFFFFF;
	uuid_t.timeMid = (UINT16)((uuid_time >>32) & 0xFFFF);
	uuid_t.timeHi_Version = (UINT16)((uuid_time >> 48) & 0x0FFF);
	uuid_t.timeHi_Version |= (1 << 12);

	// Get the clock sequence.
	clkSeq = (UINT16)(0x0601/*jiffies*/ & 0xFFFF);		// Again, we fix this to make JumpStart happy!
	uuid_t.clockSeqLow = clkSeq & 0xFF;
	uuid_t.clockSeqHi_Var = (clkSeq & 0x3F00) >> 8;
	uuid_t.clockSeqHi_Var |= 0x80;

#ifdef CONFIG_AP_SUPPORT
	// copy the Mac address as the value of node
	NdisMoveMemory(&uuid_t.node[0], &pAd->ApCfg.MBSSID[apIdx].Bssid[0], sizeof(uuid_t.node));
#endif // CONFIG_AP_SUPPORT //


	// Create the UUID ASCII string.
	snprintf(uuidAscStr, UUID_LEN_STR, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
			(unsigned int)uuid_t.timeLow, uuid_t.timeMid, uuid_t.timeHi_Version, uuid_t.clockSeqHi_Var, uuid_t.clockSeqLow, 
			uuid_t.node[0], uuid_t.node[1], uuid_t.node[2], uuid_t.node[3], uuid_t.node[4], uuid_t.node[5]);

	// Create the UUID Hex format number
	uuid_t.timeLow = cpu2be32(uuid_t.timeLow);
	NdisMoveMemory(&uuidHexStr[0], &uuid_t.timeLow, 4);
	uuid_t.timeMid = cpu2be16(uuid_t.timeMid);
	NdisMoveMemory(&uuidHexStr[4], &uuid_t.timeMid, 2);
	uuid_t.timeHi_Version = cpu2be16(uuid_t.timeHi_Version);
	NdisMoveMemory(&uuidHexStr[6], &uuid_t.timeHi_Version, 2);
	NdisMoveMemory(&uuidHexStr[8], &uuid_t.clockSeqHi_Var, 1);
	NdisMoveMemory(&uuidHexStr[9], &uuid_t.clockSeqLow, 1);
	NdisMoveMemory(&uuidHexStr[10], &uuid_t.node[0], 6);

	printk("The UUID Hex string is:");
	for (i=0; i< 16; i++)
	{
		printk("%02x", (uuidHexStr[i] & 0xff));
	}
	printk("\n");
	printk("The UUID ASCII string is:%s!\n", uuidAscStr);
	return 0;
}


VOID    WscStateMachineInit(
	IN	PRTMP_ADAPTER		pAdapter, 
	IN	STATE_MACHINE		*S, 
	OUT	STATE_MACHINE_FUNC	Trans[])	
{
#ifdef CONFIG_AP_SUPPORT
	UCHAR         apidx = MAIN_MBSSID;
#endif // CONFIG_AP_SUPPORT //

	StateMachineInit(S,	(STATE_MACHINE_FUNC*)Trans, MAX_WSC_STATE, MAX_WSC_MSG, (STATE_MACHINE_FUNC)Drop, WSC_IDLE, WSC_MACHINE_BASE);
#ifdef CONFIG_AP_SUPPORT
    StateMachineSetAction(S, WSC_IDLE, WSC_EAPOL_START_MSG, (STATE_MACHINE_FUNC)WscEAPOLStartAction);
#endif // CONFIG_AP_SUPPORT //
	StateMachineSetAction(S, WSC_IDLE, WSC_EAPOL_PACKET_MSG, (STATE_MACHINE_FUNC)WscEAPAction);
    StateMachineSetAction(S, WSC_IDLE, WSC_EAPOL_UPNP_MSG, (STATE_MACHINE_FUNC)WscEAPAction);

#ifdef CONFIG_AP_SUPPORT
//    for (apidx = MAIN_MBSSID; apidx < MAX_MBSSID_NUM; apidx++)
    // Support WSC in ra0 now 2006.11.08
    {
    	WSC_TIMER_INIT(pAdapter, &pAdapter->ApCfg.MBSSID[apidx].WscControl, &pAdapter->ApCfg.MBSSID[apidx].WscControl.EapolTimer, pAdapter->ApCfg.MBSSID[apidx].WscControl.EapolTimerRunning, WscEAPOLTimeOutAction);
    	WSC_TIMER_INIT(pAdapter, &pAdapter->ApCfg.MBSSID[apidx].WscControl, &pAdapter->ApCfg.MBSSID[apidx].WscControl.Wsc2MinsTimer, pAdapter->ApCfg.MBSSID[apidx].WscControl.Wsc2MinsTimerRunning, Wsc2MinsTimeOutAction);

	    //create the timer used to trigger timeout handler when UPnP STATE MACHINE failed.
    	WSC_TIMER_INIT(pAdapter, &pAdapter->ApCfg.MBSSID[apidx].WscControl, &pAdapter->ApCfg.MBSSID[apidx].WscControl.WscUPnPNodeInfo.UPnPMsgTimer, pAdapter->ApCfg.MBSSID[apidx].WscControl.WscUPnPNodeInfo.bUPnPMsgTimerRunning, WscUPnPMsgTimeOutAction);
        pAdapter->ApCfg.MBSSID[apidx].WscControl.WscUPnPNodeInfo.bUPnPMsgTimerPending = FALSE;
    	WSC_TIMER_INIT(pAdapter, &pAdapter->ApCfg.MBSSID[apidx].WscControl, &pAdapter->ApCfg.MBSSID[apidx].WscControl.WscUPnPNodeInfo.UPnPM2DTimer, pAdapter->ApCfg.MBSSID[apidx].WscControl.WscUPnPNodeInfo.bUPnPM2DTimerRunning, WscUPnPM2DTimeOutAction);

#ifdef OLD_DH_KEY
        WSC_VMALLOC_KEY_MEM(pAdapter->ApCfg.MBSSID[apidx].WscControl.pPubKeyMem, pAdapter->ApCfg.MBSSID[apidx].WscControl.pSecKeyMem, 15*MAX_NN_DIGITS+1);
#endif //OLD_DH_KEY
    }

#ifdef APCLI_SUPPORT
    WSC_TIMER_INIT(pAdapter, &pAdapter->ApCfg.ApCliTab[apidx].WscControl, &pAdapter->ApCfg.ApCliTab[apidx].WscControl.EapolTimer, pAdapter->ApCfg.ApCliTab[apidx].WscControl.EapolTimerRunning, WscEAPOLTimeOutAction);
	WSC_TIMER_INIT(pAdapter, &pAdapter->ApCfg.ApCliTab[apidx].WscControl, &pAdapter->ApCfg.ApCliTab[apidx].WscControl.Wsc2MinsTimer, pAdapter->ApCfg.ApCliTab[apidx].WscControl.Wsc2MinsTimerRunning, Wsc2MinsTimeOutAction);

    //create the timer used to trigger timeout handler when UPnP STATE MACHINE failed.
	WSC_TIMER_INIT(pAdapter, &pAdapter->ApCfg.ApCliTab[apidx].WscControl, &pAdapter->ApCfg.ApCliTab[apidx].WscControl.WscUPnPNodeInfo.UPnPMsgTimer, pAdapter->ApCfg.ApCliTab[apidx].WscControl.WscUPnPNodeInfo.bUPnPMsgTimerRunning, WscUPnPMsgTimeOutAction);
    pAdapter->ApCfg.ApCliTab[apidx].WscControl.WscUPnPNodeInfo.bUPnPMsgTimerPending = FALSE;
	WSC_TIMER_INIT(pAdapter, &pAdapter->ApCfg.ApCliTab[apidx].WscControl, &pAdapter->ApCfg.ApCliTab[apidx].WscControl.WscUPnPNodeInfo.UPnPM2DTimer, pAdapter->ApCfg.ApCliTab[apidx].WscControl.WscUPnPNodeInfo.bUPnPM2DTimerRunning, WscUPnPM2DTimeOutAction);

#ifdef OLD_DH_KEY
    WSC_VMALLOC_KEY_MEM(pAdapter->ApCfg.ApCliTab[apidx].WscControl.pPubKeyMem, pAdapter->ApCfg.ApCliTab[apidx].WscControl.pSecKeyMem, 15*MAX_NN_DIGITS+1);
#endif //OLD_DH_KEY
#endif // APCLI_SUPPORT //

#endif // CONFIG_AP_SUPPORT //

}

void WscUPnPM2DTimeOutAction(
    IN PVOID SystemSpecific1, 
    IN PVOID FunctionContext, 
    IN PVOID SystemSpecific2, 
    IN PVOID SystemSpecific3)
{
	/* For each state, we didn't care about the retry issue, we just send control message
		to notify the UPnP deamon that some error happened in STATE MACHINE.
	*/
	PWSC_CTRL pWscControl = (PWSC_CTRL)FunctionContext;
    PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pWscControl->pAd;
	WSC_UPNP_NODE_INFO	*pWscNodeInfo;
#ifdef CONFIG_AP_SUPPORT
	MAC_TABLE_ENTRY		*pEntry;
//	UCHAR		        apidx = MAIN_MBSSID;
#endif // CONFIG_AP_SUPPORT //    
    BOOLEAN             Cancelled;
	
#ifdef CONFIG_AP_SUPPORT
    pEntry = MacTableLookup(pAd, pWscControl->EntryAddr);
#endif // CONFIG_AP_SUPPORT //
	pWscNodeInfo = &pWscControl->WscUPnPNodeInfo;
	
	DBGPRINT(RT_DEBUG_TRACE, ("UPnP StateMachine TimeOut(State=%d!)\n", pWscControl->WscState));

#ifdef CONFIG_AP_SUPPORT
	if ((pEntry == NULL) || (pWscNodeInfo->registrarID != 0))
#endif // CONFIG_AP_SUPPORT //
	{
		DBGPRINT(RT_DEBUG_TRACE, ("%s():pEntry maybe gone or already received M2 Packet!\n", __FUNCTION__));
		goto done;
	}
	
	if (pWscNodeInfo->M2DACKBalance != 0)
	{
		DBGPRINT(RT_DEBUG_TRACE, ("%s(): waiting for M2DACK balance, extend the time!\n", __FUNCTION__));
		// Waiting for M2DACK balance.
		RTMPModTimer(&pWscNodeInfo->UPnPM2DTimer, WSC_EAP_ID_TIME_OUT);
		return;
	}
	else
    {	
		RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
		pWscControl->EapolTimerRunning = FALSE;

#ifdef CONFIG_AP_SUPPORT
	    DBGPRINT(RT_DEBUG_TRACE, ("%s(): send EAP-Fail to wireless Station!\n", __FUNCTION__));
    	// Send EAPFail to Wireless Station and reset the status of Wsc.
		WscSendEapFail(pAd);
		pEntry->bWscCapable = FALSE;
#endif // CONFIG_AP_SUPPORT //
		pWscControl->EapMsgRunning = FALSE;                
		pWscControl->EntryApIdx = WSC_INIT_ENTRY_APIDX;
		pWscControl->WscState = WSC_STATE_OFF;
    }
	
done:
	pWscNodeInfo->bUPnPM2DTimerRunning = FALSE;
	pWscNodeInfo->M2DACKBalance = 0;
	pWscNodeInfo->registrarID = 0;
		
	
}


VOID WscUPnPMsgTimeOutAction(
    IN PVOID SystemSpecific1, 
    IN PVOID FunctionContext, 
    IN PVOID SystemSpecific2, 
    IN PVOID SystemSpecific3)
{
	PWSC_CTRL pWscControl = (PWSC_CTRL)FunctionContext;
	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER)pWscControl->pAd;
	WSC_UPNP_NODE_INFO	*pWscNodeInfo;

	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscUPnPMsgTimeOutAction\n"));

	//It shouldn't happened!
	if (!pWscControl)
		return;
	
	pWscNodeInfo = &pWscControl->WscUPnPNodeInfo;
	
	DBGPRINT(RT_DEBUG_TRACE, ("UPnP StateMachine TimeOut(State=%d!)\n", pWscControl->WscState));

    if (pWscNodeInfo->bUPnPMsgTimerPending)
    {
#define WSC_UPNP_TIMER_PENDIND_WAIT	2000

        RTMPModTimer(&pWscNodeInfo->UPnPMsgTimer, WSC_UPNP_TIMER_PENDIND_WAIT);
        DBGPRINT(RT_DEBUG_TRACE, ("UPnPMsgTimer Pending......\n"));
        DBGPRINT(RT_DEBUG_TRACE, ("<----- WscUPnPMsgTimeOutAction\n"));
        return;
    } else {
		int dataLen;
		UCHAR *pWscData;

		if( (pWscData = kmalloc(WSC_MAX_DATA_LEN, GFP_ATOMIC)))
		{
			memset(pWscData, 0, WSC_MAX_DATA_LEN);

			dataLen = BuildMessageNACK(pAd, pWscControl, pWscData);
			WscSendUPnPMessage(pAd, WSC_OPCODE_UPNP_DATA, WSC_UPNP_DATA_SUB_NORMAL, pWscData, 
								dataLen, 0, 0, &pAd->CurrentAddress[0]);
			
			kfree(pWscData);
		}
	
		pWscNodeInfo->bUPnPInProgress = FALSE;
		pWscNodeInfo->bUPnPMsgTimerPending = FALSE;
		pWscNodeInfo->bUPnPMsgTimerRunning = FALSE;
		pWscControl->WscState = WSC_STATE_OFF;
		pWscControl->WscStatus = STATUS_WSC_FAIL;
    }
	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscUPnPMsgTimeOutAction\n"));
		
}

#ifdef CONFIG_AP_SUPPORT
VOID WscEAPOLStartAction(
    IN PRTMP_ADAPTER    pAd, 
    IN MLME_QUEUE_ELEM  *Elem) 
{
    MAC_TABLE_ENTRY     *pEntry;
    BOOLEAN             Cancelled;

    DBGPRINT(RT_DEBUG_TRACE, ("-----> WscEAPOLStartAction\n"));

    if (Elem->MsgLen == 6)
        pEntry = MacTableLookup(pAd, Elem->Msg);
    else
    {
        PHEADER_802_11      pHeader;
        pHeader = (PHEADER_802_11)Elem->Msg;
        pEntry = MacTableLookup(pAd, pHeader->Addr2);
    }

    if (pEntry == NULL)
    {
        DBGPRINT(RT_DEBUG_TRACE, ("pEntry is NULL.\n"));
        DBGPRINT(RT_DEBUG_TRACE, ("<----- WscEAPOLStartAction\n"));
        return;
    }
    
    if (pEntry->Receive_EapolStart_EapRspId == 0)
    {
        pEntry->Receive_EapolStart_EapRspId |= WSC_ENTRY_GET_EAPOL_START;
        if (Elem->MsgLen != 6)
        {
            DBGPRINT(RT_DEBUG_TRACE, ("WscEAPOLStartAction - receive EAPOL-Start from %02x:%02x:%02x:%02x:%02x:%02x\n",
                                     pEntry->Addr[0],
                                     pEntry->Addr[1],
                                     pEntry->Addr[2],
                                     pEntry->Addr[3],
                                     pEntry->Addr[4],
                                     pEntry->Addr[5]));
            pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EapMsgRunning = TRUE;
            pEntry->EnqueueEapolStartTimerForWscRunning = FALSE;
            RTMPCancelTimer(&pEntry->EnqueueEapolStartTimerForWsc, &Cancelled);
        }
        if (pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryApIdx == WSC_INIT_ENTRY_APIDX)
        {
            WscInitEntryFunc(pEntry);
        }
        
        pEntry->bWscCapable = TRUE;
        DBGPRINT(RT_DEBUG_TRACE, ("WscEAPOLStartAction(ra%d) - send EAP-Req(Id) to %02x:%02x:%02x:%02x:%02x:%02x\n",
                                 pEntry->apidx,
                                 pEntry->Addr[0],
                                 pEntry->Addr[1],
                                 pEntry->Addr[2],
                                 pEntry->Addr[3],
                                 pEntry->Addr[4],
                                 pEntry->Addr[5]));
        WscSendEapReqId(pAd, pEntry);
//        pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscState = WSC_STATE_WAIT_RESP_ID;
        if (!pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EapolTimerRunning)
        {
            pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EapolTimerRunning = TRUE;
            RTMPSetTimer(&pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EapolTimer, WSC_EAP_ID_TIME_OUT);
        }
    } 
    else
        DBGPRINT(RT_DEBUG_TRACE, ("Ignore EAPOL-Start.\n"));
    
    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscEAPOLStartAction\n"));
}
#endif // CONFIG_AP_SUPPORT //

VOID WscEAPAction(
	IN	PRTMP_ADAPTER	pAdapter, 
	IN	MLME_QUEUE_ELEM	*Elem) 
{		
    UCHAR               MsgType;
    BOOLEAN             bUPnPMsg, Cancelled;
    MAC_TABLE_ENTRY     *pEntry = NULL;
#ifdef CONFIG_AP_SUPPORT
    UCHAR               MacAddr[MAC_ADDR_LEN] = {0};
    UCHAR               apidx = MAIN_MBSSID;
#endif // CONFIG_AP_SUPPORT //
    PWSC_CTRL           pWscControl;
    PWSC_UPNP_NODE_INFO pWscUPnPNodeInfo = NULL;
	
	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscEAPAction\n"));

#ifdef CONFIG_AP_SUPPORT
	memmove(MacAddr, Elem->Msg, MAC_ADDR_LEN);
	memmove(Elem->Msg, Elem->Msg+6, Elem->MsgLen);
#endif // CONFIG_AP_SUPPORT //

#ifdef DBG
    hex_dump("(WscEAPAction)Elem->MsgLen", Elem->Msg, Elem->MsgLen);
#endif /* DBG */

	MsgType = WscRxMsgType(pAdapter, Elem);
	bUPnPMsg = Elem->MsgType == WSC_EAPOL_UPNP_MSG ? TRUE : FALSE;

#ifdef CONFIG_AP_SUPPORT
	DBGPRINT(RT_DEBUG_TRACE, ("WscEAPAction: Addr: %02x:%02x:%02x:%02x:%02x:%02x, MsgType: 0x%02X, bUPnPMsg: %s\n",
			MacAddr[0], MacAddr[1], MacAddr[2], MacAddr[3], MacAddr[4], MacAddr[5], MsgType, bUPnPMsg ? "TRUE" : "FALSE"));
#endif // CONFIG_AP_SUPPORT //
			
#ifdef CONFIG_AP_SUPPORT
    if (!bUPnPMsg)
    {
    	// Messages from EAP
        pEntry = MacTableLookup(pAdapter, MacAddr);
        if (pEntry)
        {
            if (pEntry->ValidAsCLI && pEntry->apidx != MAIN_MBSSID)
            {
                DBGPRINT(RT_DEBUG_TRACE, ("WscEAPAction: Only support WSC in ra0 now.\n"));
                DBGPRINT(RT_DEBUG_TRACE, ("<----- WscEAPAction\n"));
                return;
            }
        }
        else
        {
            DBGPRINT(RT_DEBUG_TRACE, ("WscEAPAction: pEntry is NULL.\n"));
            DBGPRINT(RT_DEBUG_TRACE, ("<----- WscEAPAction\n"));
            return;
        }
        if (pEntry->ValidAsCLI)
        {
            if ((MsgType == WSC_MSG_EAP_REG_RSP_ID) || (MsgType == WSC_MSG_EAP_ENR_RSP_ID))
            {
                if ((pEntry->Receive_EapolStart_EapRspId & WSC_ENTRY_GET_EAP_RSP_ID) == WSC_ENTRY_GET_EAP_RSP_ID)
                {
                    DBGPRINT(RT_DEBUG_TRACE, ("WscEAPAction: Already receive EAP_RSP(Identitry) from this STA, ignore it.\n"));
                    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscEAPAction\n"));
                    return;
                }
                else
                    pEntry->Receive_EapolStart_EapRspId |= WSC_ENTRY_GET_EAP_RSP_ID;
            }
        }
#ifdef APCLI_SUPPORT
    // for ap-client packets 
    if (pEntry->ValidAsApCli)
        pWscControl = &pAdapter->ApCfg.ApCliTab[apidx].WscControl;
    else
#endif // APCLI_SUPPORT //
	    pWscControl = &pAdapter->ApCfg.MBSSID[apidx].WscControl;
    }
	else
	{
		int i;
		for (i = 0 ; i < MAX_MBSSID_NUM; i++)
		{
			if(NdisEqualMemory(pAdapter->ApCfg.MBSSID[i].Bssid, MacAddr, MAC_ADDR_LEN))
			{
				apidx = i;
				break;
			}
		}
		pWscControl = &pAdapter->ApCfg.MBSSID[apidx].WscControl;
		pWscUPnPNodeInfo = &pAdapter->ApCfg.MBSSID[apidx].WscControl.WscUPnPNodeInfo;
		pWscUPnPNodeInfo->bUPnPMsgTimerPending = TRUE;
	}
#endif // CONFIG_AP_SUPPORT //
	

	pWscControl->EapolTimerPending = TRUE;
	
#ifdef CONFIG_AP_SUPPORT
	if ((pWscControl->WscConfMode & WSC_ENROLLEE_PROXY_REGISTRAR) == WSC_DISABLE)
	{
		DBGPRINT(RT_DEBUG_TRACE, ("WscEAPAction(ra%d): Wsc StateMachine is disabled!\n", apidx));
		DBGPRINT(RT_DEBUG_TRACE, ("<----- WscEAPAction\n"));
		goto out;
	}
#endif // CONFIG_AP_SUPPORT //

#ifdef CONFIG_AP_SUPPORT
	if (MsgType == WSC_MSG_EAP_REG_RSP_ID)
	{
        if (((pWscControl->WscConfMode & WSC_ENROLLEE) != 0) ||
            (((pWscControl->WscConfMode & WSC_PROXY) != 0) && bUPnPMsg))
        {
            if (!bUPnPMsg && !pWscControl->bWscTrigger)
                ;
            else
            {
                gWscActionMode = WSC_ENROLLEE;
                pWscControl->WscUseUPnP = bUPnPMsg ? 1 : 0;
        		MsgType = WSC_MSG_EAP_RSP_ID;
                WscEapEnrolleeAction(pAdapter, Elem, WSC_MSG_EAP_RSP_ID, pEntry, pWscControl);
            }
        }
    }
    else if (MsgType == WSC_MSG_EAP_ENR_RSP_ID)
    {
        DBGPRINT(RT_DEBUG_TRACE, ("WscEAPAction: Rx Identity\n"));
        gWscActionMode = WSC_REGISTRAR;
        if (bUPnPMsg)
        {
            // receive enrollee identity from UPnP
        }
        else
        {
            // receive enrollee identity from EAP
            if ((pWscControl->WscConfMode & WSC_PROXY_REGISTRAR) != 0)
            {
                // Notify UPnP daemon before send Eap-Req(wsc-start)
    		    DBGPRINT(RT_DEBUG_TRACE, ("%s: pEntry->Addr=%02x:%02x:%02x:%02x:%02x:%02x\n", __FUNCTION__,
    		    		pEntry->Addr[0], pEntry->Addr[1], pEntry->Addr[2], pEntry->Addr[3], pEntry->Addr[4], pEntry->Addr[5]));
    			WscSendUPnPConfReqMsg(pAdapter, pAdapter->ApCfg.MBSSID[pEntry->apidx].Ssid, pEntry->Addr, 2, 0);
                // Reset the UPnP timer and status.
    			if (pWscControl->WscUPnPNodeInfo.bUPnPM2DTimerRunning == TRUE)
    			{
    				RTMPCancelTimer(&pWscControl->WscUPnPNodeInfo.UPnPM2DTimer, &Cancelled);
    				pWscControl->WscUPnPNodeInfo.bUPnPM2DTimerRunning = FALSE;
    			}
                pWscControl->WscUPnPNodeInfo.registrarID = 0;
        		pWscControl->WscUPnPNodeInfo.M2DACKBalance = 0;
                WscDelWPARetryTimer(pAdapter);
                pWscControl->EapMsgRunning = TRUE;
    			// Change the state to next one
    			pWscControl->WscState = WSC_STATE_WAIT_M1;
                // send EAP WSC_START
                if (pEntry->ValidAsCLI)
                    WscSendMessage(pAdapter, WSC_OPCODE_START, NULL, 0, pWscControl, AP_MODE);
            }
        }
    }
    else 
#endif // CONFIG_AP_SUPPORT //
    if (MsgType == WSC_MSG_EAP_REQ_ID)
    {        
        DBGPRINT(RT_DEBUG_TRACE, ("Receive EAP_Req/Identity from WPS AP or WCN\n"));
		if (bUPnPMsg && (pWscControl->WscConfMode == WSC_ENROLLEE))
		{
			gWscActionMode = WSC_ENROLLEE;
            pWscControl->WscUseUPnP = 1;
            WscEapEnrolleeAction(pAdapter, Elem, WSC_MSG_EAP_REQ_START, pEntry, pWscControl);
		}
		else
        {      
#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
        	WscSendEapRspId(pAdapter, pEntry, pWscControl); // Receive EAP_Req/Identity from WPS AP
#endif // APCLI_SUPPORT //
#endif // CONFIG_AP_SUPPORT //
        }
        
        if (!bUPnPMsg)
        {
            if (pWscControl->WscConfMode == WSC_REGISTRAR)
                pWscControl->WscState = WSC_STATE_WAIT_M1;
            else
                pWscControl->WscState = WSC_STATE_WAIT_WSC_START;
        }
    }
    else if (MsgType == WSC_MSG_EAP_REQ_START)
    {
        // Receive EAP_Req(Wsc_Start) from WPS AP        
        if (pWscControl->WscConfMode == WSC_ENROLLEE)
        {
            gWscActionMode = WSC_ENROLLEE;
            pWscControl->WscUseUPnP = bUPnPMsg ? 1 : 0;
            DBGPRINT(RT_DEBUG_TRACE, ("Receive EAP_Req(Wsc_Start) from WPS AP\n"));
            WscEapEnrolleeAction(pAdapter, Elem, WSC_MSG_EAP_REQ_START, pEntry, pWscControl);

            if (!pWscControl->EapolTimerRunning)
            {
                pWscControl->EapolTimerRunning = TRUE;
                RTMPSetTimer(&pWscControl->EapolTimer, WSC_EAP_ID_TIME_OUT);
            }
        }
        else
            DBGPRINT(RT_DEBUG_TRACE, ("Ignore EAP_Req(Wsc_Start) from WPS AP\n"));
    }
    else if (MsgType == WSC_MSG_EAP_FAIL)
    {
        // Receive EAP_Fail from WPS AP
        DBGPRINT(RT_DEBUG_TRACE, ("Receive EAP_Fail from WPS AP\n"));
        if (pWscControl->WscState >= WSC_STATE_WAIT_EAPFAIL)
        {            
            pWscControl->WscState = WSC_STATE_OFF;
			pWscControl->WscStatus = STATUS_WSC_CONFIGURED;
#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
            pWscControl->WscConfMode = WSC_DISABLE;
    		// bring apcli interface down first
    		if(pEntry->ValidAsApCli && pAdapter->ApCfg.ApCliTab[pEntry->apidx].Enable == TRUE )
    		{
    			pAdapter->ApCfg.ApCliTab[pEntry->apidx].Enable = FALSE;
    			ApCliIfDown(pAdapter);
                pAdapter->ApCfg.ApCliTab[pEntry->apidx].Enable = TRUE;
    		}
#endif // APCLI_SUPPORT //
#endif // CONFIG_AP_SUPPORT //
        }
        else if (pWscControl->WscState == WSC_STATE_RX_M2D)
        {
            // Wait M2;
        }
        else
        {
            pWscControl->WscStatus = STATUS_WSC_FAIL;	

			// Change the state to next one
			pWscControl->WscState = WSC_STATE_OFF;
            //pWscControl->WscConfMode = WSC_DISABLE;
        }
    }
    else if (MsgType == WSC_MSG_M1)
    {
        if ((pWscControl->WscConfMode & WSC_REGISTRAR) != 0 &&
             pWscControl->bWscTrigger)
        {
            gWscActionMode = WSC_REGISTRAR;
            // If Message is from EAP, but UPnP Registrar is in progress now, ignore EAP_M1
            if (!bUPnPMsg && pWscControl->WscUPnPNodeInfo.bUPnPInProgress)
            {
                WscEapActionDisabled(pAdapter, pWscControl);
                DBGPRINT(RT_DEBUG_TRACE, ("UPnP Registrar is working now, ignore EAP M1.\n"));
                goto out;
            }
            else
                WscEapRegistrarAction(pAdapter, Elem, MsgType, pEntry, pWscControl);
        }
#ifdef CONFIG_AP_SUPPORT
        if (((pWscControl->WscConfMode & WSC_PROXY) != 0) && !bUPnPMsg)
        {
            if (pWscControl->bWscTrigger && (pWscControl->WscState >= WSC_STATE_WAIT_M3))
                ;
            else
            {
                gWscActionMode = WSC_PROXY;
                WscEapApProxyAction(pAdapter, Elem, MsgType, pEntry, pWscControl);
            }
        }
        else if (!pWscControl->bWscTrigger && ((pWscControl->WscConfMode & WSC_PROXY) == 0))
#endif // CONFIG_AP_SUPPORT //
        {
            WscEapActionDisabled(pAdapter, pWscControl);
            DBGPRINT(RT_DEBUG_TRACE, ("WscTrigger is FALSE, ignore EAP M1.\n"));
            goto out;
        }
    }
    else if (MsgType == WSC_MSG_M3 ||
             MsgType == WSC_MSG_M5 ||
             MsgType == WSC_MSG_M7 ||
             MsgType == WSC_MSG_WSC_DONE)
    {
        if (((pWscControl->WscConfMode & WSC_REGISTRAR) != 0) &&
              pWscControl->bWscTrigger &&
              WscCheckNonce(pAdapter, Elem, TRUE, pWscControl))
        {
            // If Message is from EAP, but UPnP Registrar is in progress now, ignore EAP Messages
            if (!bUPnPMsg && pWscControl->WscUPnPNodeInfo.bUPnPInProgress)
            {
                WscEapActionDisabled(pAdapter, pWscControl);
                DBGPRINT(RT_DEBUG_TRACE, ("UPnP Registrar is working now, ignore EAP Messages.\n"));
                goto out;
            }
            else
            {
                gWscActionMode = WSC_REGISTRAR;
                WscEapRegistrarAction(pAdapter, Elem, MsgType, pEntry, pWscControl);
            }
        }
#ifdef CONFIG_AP_SUPPORT        
        else if (((pWscControl->WscConfMode & WSC_PROXY) != 0) && !bUPnPMsg)
        {
            gWscActionMode = WSC_PROXY;
            WscEapApProxyAction(pAdapter, Elem, MsgType, pEntry, pWscControl);
        }
#endif // CONFIG_AP_SUPPORT //        
    }
    else if (MsgType == WSC_MSG_M2 ||
             MsgType == WSC_MSG_M2D ||
             MsgType == WSC_MSG_M4 ||
             MsgType == WSC_MSG_M6 ||
             MsgType == WSC_MSG_M8)
    {
        if (((pWscControl->WscConfMode & WSC_ENROLLEE) != 0) &&
              pWscControl->bWscTrigger &&
              WscCheckNonce(pAdapter, Elem, FALSE, pWscControl))
        {
            gWscActionMode = WSC_ENROLLEE;
            pWscControl->WscUseUPnP = bUPnPMsg ? 1 : 0;
            if (MsgType == WSC_MSG_M2)
            {
                WscGetRegDataPIN(pAdapter, pWscControl->WscEnrolleePinCode, pWscControl);
                DBGPRINT(RT_DEBUG_TRACE, ("WscEnrolleePinCode: %08u\n", pWscControl->WscEnrolleePinCode));
            }
            // If Message is from EAP, but UPnP Registrar is in progress now, ignore EAP Messages
            if (!bUPnPMsg && pWscControl->WscUPnPNodeInfo.bUPnPInProgress)
            {
                WscEapActionDisabled(pAdapter, pWscControl);
                DBGPRINT(RT_DEBUG_TRACE, ("UPnP Registrar is working now, ignore EAP Messages.\n"));
                goto out;
            }
            else
                WscEapEnrolleeAction(pAdapter, Elem, MsgType, pEntry, pWscControl);
        }
#ifdef CONFIG_AP_SUPPORT        
        else if ((pWscControl->WscConfMode & WSC_PROXY) != 0 && bUPnPMsg)
        {
            gWscActionMode = WSC_PROXY;
            WscEapApProxyAction(pAdapter, Elem, MsgType, pEntry, pWscControl);
        }
#endif // CONFIG_AP_SUPPORT //        
    }
    else if (MsgType == WSC_MSG_WSC_ACK)
    {
        if (((pWscControl->WscConfMode & WSC_REGISTRAR) != 0) && 
               pWscControl->bWscTrigger &&
               pWscControl->WscState <= WSC_STATE_SENT_M2D)
        {
            if (WscCheckNonce(pAdapter, Elem, TRUE, pWscControl))
            {
                gWscActionMode = WSC_REGISTRAR;
                pWscControl->WscState = WSC_STATE_WAIT_PIN;
                pWscControl->WscStatus = STATUS_WSC_WAIT_PIN_CODE;
            }
        }
        else
        {
            if (((pWscControl->WscConfMode & WSC_ENROLLEE) != 0) && 
                  pWscControl->bWscTrigger &&
                  WscCheckNonce(pAdapter, Elem, FALSE, pWscControl))
            {
                gWscActionMode = WSC_ENROLLEE;
                pWscControl->WscUseUPnP = bUPnPMsg ? 1 : 0;
                WscEapEnrolleeAction(pAdapter, Elem, MsgType, pEntry, pWscControl);
            }
#ifdef CONFIG_AP_SUPPORT            
            else if ((pWscControl->WscConfMode & WSC_PROXY) != 0)
            {
                gWscActionMode = WSC_PROXY;
                WscEapApProxyAction(pAdapter, Elem, MsgType, pEntry, pWscControl);
            }
#endif // CONFIG_AP_SUPPORT //
        }
    }
    else if (MsgType == WSC_MSG_WSC_NACK)
    {
        if (!bUPnPMsg &&
            (WscCheckNonce(pAdapter, Elem, FALSE, pWscControl) || WscCheckNonce(pAdapter, Elem, TRUE, pWscControl)))
        {
            DBGPRINT(RT_DEBUG_TRACE, ("Receive NACK from WPS client.\n"));
            WscGetConfigErrFromNack(pAdapter, Elem);
            /*
               If a PIN authentication or communication error occurs after sending message M6, 
               the Registrar MUST warn the user and MUST NOT automatically reuse the PIN. 
               Furthermore, if the Registrar detects this situation and prompts the user for a new PIN from the Enrollee device, 
               it MUST NOT accept the same PIN again without warning the user of a potential attack.
            */
            if (pWscControl->WscState >= WSC_STATE_WAIT_M5)
            {
                pWscControl->WscRejectSamePinFromEnrollee = TRUE;
                pWscControl->WscPinCode = 0;
            }
#ifdef CONFIG_AP_SUPPORT
            WscSendEapFail(pAdapter);
#endif // CONFIG_AP_SUPPORT //
            RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
            pWscControl->WscState = WSC_STATE_FAIL;
            pWscControl->WscStatus = STATUS_WSC_FAIL;
            pWscControl->RegData.ReComputePke = 1;
        }
    }
    else
    {
        DBGPRINT(RT_DEBUG_TRACE, ("Unsupported Msg Type (%02X)\n", MsgType));
        goto out;
    }
    
	if (bUPnPMsg)
	{
		// Messages from UPnP
		if (pWscUPnPNodeInfo->bUPnPMsgTimerRunning)
			RTMPModTimer(&pWscUPnPNodeInfo->UPnPMsgTimer, WSC_UPNP_MSG_TIME_OUT);
	}
	else
	{
		// Messages from EAP
		RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
		pWscControl->EapolTimerRunning = TRUE;
	}
	
	if (bUPnPMsg && pWscControl->EapolTimerRunning)
	{   
#ifdef CONFIG_AP_SUPPORT	
		if (gWscActionMode == WSC_PROXY)
		{
			RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
		}
        else
#endif // CONFIG_AP_SUPPORT //            
        {
            RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
            pWscControl->EapolTimerRunning = FALSE;
        }
    }

out:
	if (bUPnPMsg)
		pWscUPnPNodeInfo->bUPnPMsgTimerPending = FALSE;
	
    pWscControl->EapolTimerPending = FALSE;
	
	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscEAPAction\n"));
}

VOID WscEapEnrolleeAction(
	IN	PRTMP_ADAPTER	pAdapter, 
	IN	MLME_QUEUE_ELEM	*Elem,
	IN  UCHAR	        MsgType,
	IN  MAC_TABLE_ENTRY *pEntry,
	IN  PWSC_CTRL       pWscControl)
{
    INT     DataLen = 0, rv = 0, DH_Len = 0;
    UCHAR   OpCode;
    PUCHAR  WscData = NULL;
    BOOLEAN bUPnPMsg, bUPnPStatus = FALSE, Cancelled;
	WSC_UPNP_NODE_INFO *pWscUPnPInfo = &pWscControl->WscUPnPNodeInfo;

    DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction Enter!\n"));

	bUPnPMsg = Elem->MsgType == WSC_EAPOL_UPNP_MSG ? TRUE : FALSE;
	OpCode = bUPnPMsg ? WSC_OPCODE_UPNP_MASK : 0;

#ifdef CONFIG_AP_SUPPORT
	// Early check. 
	if ((gWscActionMode != WSC_ENROLLEE) ||
		(pWscControl->WscUseUPnP && pEntry) ||
		(pWscControl->WscUseUPnP == 0 && (!pEntry)))
	{	
		DBGPRINT(RT_DEBUG_TRACE, ("EarlyCheckFailed: gWscActionMode=%d, Configured=%d, WscUseUPnP=%d, pEntry=%p!\n", 
					gWscActionMode, pWscControl->WscConfStatus, pWscControl->WscUseUPnP, pEntry));
		goto Fail;
	}
#endif // CONFIG_AP_SUPPORT //
	DBGPRINT(RT_DEBUG_TRACE, ("MsgType=0x%x, WscState=%d, bUPnPMsg=%d!\n", MsgType, pWscControl->WscState, bUPnPMsg));

	if (bUPnPMsg)
	{	
#ifdef CONFIG_AP_SUPPORT
        if (MsgType == WSC_MSG_EAP_RSP_ID)
#endif // CONFIG_AP_SUPPORT //
        {
           //let it pass
        }
        else if(MsgType ==WSC_MSG_M2 && pWscUPnPInfo->bUPnPInProgress == FALSE)
        {
#ifdef CONFIG_AP_SUPPORT
            if(pWscControl->EntryApIdx != WSC_INIT_ENTRY_APIDX)
			{
			    MAC_TABLE_ENTRY *tempEntry;
    			tempEntry = MacTableLookup(pAdapter, &pWscControl->EntryAddr[0]);
                if (tempEntry)
                {
                    if((tempEntry->Receive_EapolStart_EapRspId & WSC_ENTRY_GET_EAP_RSP_ID) == WSC_ENTRY_GET_EAP_RSP_ID)
                    {
            			goto Done;
                    }
                }
                /* else cannot find the pEntry, so we need to handle this msg. */           
            } 
#endif // CONFIG_AP_SUPPORT //
    		pWscUPnPInfo->bUPnPInProgress = TRUE;
    		//Set the WscState as "WSC_STATE_WAIT_RESP_ID" because UPnP start from this state.
    		//pWscControl->WscState = WSC_STATE_WAIT_RESP_ID;
    		RTMPSetTimer(&pWscUPnPInfo->UPnPMsgTimer, WSC_UPNP_MSG_TIME_OUT);
    		pWscUPnPInfo->bUPnPMsgTimerRunning = TRUE; 
        }
        else 
        {
            // For other messages, we must make sure pWscUPnPInfo->bUPnPInProgress== TRUE
            if (pWscUPnPInfo->bUPnPInProgress == FALSE)
            {
			    goto Done;
            }
        }
	}

	if( (WscData = kmalloc(WSC_MAX_DATA_LEN, GFP_ATOMIC)) == NULL)
	{
		DBGPRINT(RT_DEBUG_TRACE, ("WscData Allocate failed!\n"));
		goto Fail;
	}
	memset(WscData, 0, WSC_MAX_DATA_LEN);
	
	switch (MsgType)
	{
#ifdef CONFIG_AP_SUPPORT
		case WSC_MSG_EAP_RSP_ID:
            DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction : Rx Identity\n"));
#endif // CONFIG_AP_SUPPORT //
		case WSC_MSG_EAP_REQ_START:
            if (MsgType == WSC_MSG_EAP_REQ_START)
                DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction : Rx Wsc_Start\n"));

//			if (pWscControl->WscState >= WSC_STATE_WAIT_RESP_ID)
			{
				//pWscControl->WscStatus = STATUS_WSC_EAP_RSP_ID_RECEIVED;
				
				if (pWscControl->RegData.ReComputePke == 1)
				{
			    	GenerateDHPublicKey(pWscControl->pPubKeyMem, pWscControl->RegData.EnrolleeRandom, 192, pWscControl->RegData.Pke, &DH_Len);
			    	pWscControl->RegData.ReComputePke = 0;
			    }

				OpCode |= WSC_OPCODE_MSG;
                
				DataLen = BuildMessageM1(pAdapter, pWscControl, WscData);
				pWscControl->WscStatus = STATUS_WSC_EAP_M1_SENT;
				if(!bUPnPMsg)
				{
#ifdef CONFIG_AP_SUPPORT		
                    if (pEntry->ValidAsCLI)
	                    WscDelWPARetryTimer(pAdapter);
#endif // CONFIG_AP_SUPPORT //
                	pWscControl->EapMsgRunning = TRUE;
				}
                
				// Change the state to next one
				if (pWscControl->WscState < WSC_STATE_SENT_M1)
			        pWscControl->WscState = WSC_STATE_SENT_M1;
			}
			break;
			
		case WSC_MSG_M2:
            DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction : Rx M2\n"));
            
			// Receive M2, if we are at WSC_STATE_WAIT_M2 start, process it immediately
			if (pWscControl->WscState == WSC_STATE_SENT_M1 ||
                pWscControl->WscState == WSC_STATE_RX_M2D)
			{
				// Process M2
				pWscControl->WscStatus = STATUS_WSC_EAP_M2_RECEIVED;
				if ((rv = ProcessMessageM2(pAdapter, Elem->Msg, Elem->MsgLen, &pWscControl->RegData)))
                    goto Fail;
                else
                {
                    OpCode |= WSC_OPCODE_MSG;
    				DataLen = BuildMessageM3(pAdapter, pWscControl, WscData);
    				pWscControl->WscStatus = STATUS_WSC_EAP_M3_SENT;
    				
    				// Change the state to next one
    				pWscControl->WscState = WSC_STATE_WAIT_M4;
                }
			}
			break;
			
		case WSC_MSG_M2D:
            DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction : Rx M2D\n"));
            
			// Receive M2D, if we are at WSC_STATE_WAIT_M2 start, process it immediately
			if (pWscControl->WscState == WSC_STATE_SENT_M1 ||
                pWscControl->WscState == WSC_STATE_RX_M2D)
			{
				if ((rv = ProcessMessageM2D(pAdapter, Elem->Msg, Elem->MsgLen, &pWscControl->RegData)))
                    goto Fail;
                
				pWscControl->WscStatus = STATUS_WSC_EAP_M2D_RECEIVED;
				
				OpCode |= WSC_OPCODE_ACK;
				DataLen = BuildMessageACK(pAdapter, pWscControl, WscData);

				// Change the state to next one
				pWscControl->WscState = WSC_STATE_RX_M2D;
			}
			break;

		case WSC_MSG_M4: 
            DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction : Rx M4\n"));
            
			// Receive M4, if we are at WSC_STATE_WAIT_M4 start, process it immediately
			if (pWscControl->WscState == WSC_STATE_WAIT_M4)
			{       
				// Process M4
				pWscControl->WscStatus = STATUS_WSC_EAP_M4_RECEIVED;
				if ((rv = ProcessMessageM4(pAdapter, pWscControl, Elem->Msg, Elem->MsgLen, &pWscControl->RegData)))
                    goto Fail;
                else
                {
                    OpCode |= WSC_OPCODE_MSG;
    				DataLen = BuildMessageM5(pAdapter, pWscControl, WscData);
    				pWscControl->WscStatus = STATUS_WSC_EAP_M5_SENT;
                    
    				// Change the state to next one
    				pWscControl->WscState = WSC_STATE_WAIT_M6;
                }
			}
			break;

		case WSC_MSG_M6:
            DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction : Rx M6\n"));
            
			// Receive M6, if we are at WSC_STATE_WAIT_M6 start, process it immediately
			if (pWscControl->WscState == WSC_STATE_WAIT_M6)
			{      
				// Process M6
				pWscControl->WscStatus = STATUS_WSC_EAP_M6_RECEIVED;
				if ((rv=ProcessMessageM6(pAdapter, pWscControl, Elem->Msg, Elem->MsgLen, &pWscControl->RegData)))
                    goto Fail;
                else
                {
                    OpCode |= WSC_OPCODE_MSG;

    				DataLen = BuildMessageM7(pAdapter, pWscControl, WscData);
    				pWscControl->WscStatus = STATUS_WSC_EAP_M7_SENT;

    				// Change the state to next one
    				pWscControl->WscState = WSC_STATE_WAIT_M8;
                }
			}
			break;

		case WSC_MSG_M8:
            DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction : Rx M8\n"));
            
			// Receive M8, if we are at WSC_STATE_WAIT_M6 start, process it immediately
			if (pWscControl->WscState == WSC_STATE_WAIT_M8)
			{
				// Process M8
				pWscControl->WscStatus = STATUS_WSC_EAP_M8_RECEIVED;
				if ((rv=ProcessMessageM8(pAdapter, Elem->Msg, Elem->MsgLen, pWscControl)))
                    goto Fail;
                else
                {
                    OpCode |= WSC_OPCODE_DONE;
    				DataLen = BuildMessageDONE(pAdapter, pWscControl, WscData);
                    
#ifdef CONFIG_AP_SUPPORT                    
    				// Change the state to next one
#ifdef APCLI_SUPPORT
					// Ap Client only supports Inband(EAP)-Enrollee.
                    if (!bUPnPMsg && pEntry->ValidAsApCli)
                        pWscControl->WscState = WSC_STATE_WAIT_EAPFAIL;
                    else
#endif // APCLI_SUPPORT //
    				    pWscControl->WscState = WSC_STATE_WAIT_ACK;

					pWscControl->RegData.ReComputePke = 0;
#endif // CONFIG_AP_SUPPORT //

                }
			}
			break;	

#ifdef CONFIG_AP_SUPPORT
        case WSC_MSG_WSC_ACK:
            DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction : Rx ACK\n"));
            
            // Receive ACK
            if (pWscControl->WscState == WSC_STATE_WAIT_ACK)
            {
                // Process ACK
                pWscControl->WscStatus = STATUS_WSC_EAP_RAP_RSP_ACK;
                // Send out EAP-Fail
                WscSendEapFail(pAdapter);
                pWscControl->WscState = WSC_STATE_CONFIGURED;                
                pWscControl->WscStatus = STATUS_WSC_CONFIGURED;
            }
            break;
#endif // CONFIG_AP_SUPPORT //

		default:
			DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction : Unsupported Msg Type\n"));
			break;
	}
	
	if (bUPnPMsg)
	{
		if ((MsgType == WSC_MSG_M8) && (pWscControl->WscState == WSC_STATE_WAIT_ACK))
		{
			pWscControl->EapMsgRunning = FALSE;
            pWscControl->EntryApIdx = WSC_INIT_ENTRY_APIDX;
            pWscControl->WscState = WSC_STATE_CONFIGURED;
            pWscControl->WscStatus = STATUS_WSC_CONFIGURED;
			if(pWscUPnPInfo->bUPnPMsgTimerRunning == TRUE)
			{	RTMPCancelTimer(&pWscUPnPInfo->UPnPMsgTimer, &Cancelled);
            	pWscUPnPInfo->bUPnPMsgTimerRunning = FALSE;
			}
			pWscUPnPInfo->bUPnPInProgress = FALSE;
			pWscUPnPInfo->registrarID = 0;
		}
	}
	else
	{
		if ((MsgType == WSC_MSG_WSC_ACK) && (pWscControl->WscState == WSC_STATE_CONFIGURED))
		{
			RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
			pWscControl->EapolTimerRunning = FALSE;
			pWscControl->EapMsgRunning = FALSE;
            pWscControl->EntryApIdx = WSC_INIT_ENTRY_APIDX;
		}
	}
	
	if(OpCode > WSC_OPCODE_UPNP_MASK)
		bUPnPStatus = WscSendUPnPMessage(pAdapter, WSC_OPCODE_UPNP_DATA, WSC_UPNP_DATA_SUB_NORMAL, WscData, DataLen, 
											Elem->TimeStamp.u.LowPart, Elem->TimeStamp.u.HighPart, &pAdapter->CurrentAddress[0]);
	else if(OpCode > 0 && OpCode < WSC_OPCODE_UPNP_MASK)
    {   
        if (pWscControl->WscState != WSC_STATE_CONFIGURED)
        {
#ifdef CONFIG_AP_SUPPORT
            if (pEntry->ValidAsApCli)
		        WscSendMessage(pAdapter, OpCode, WscData, DataLen, pWscControl, AP_CLIENT_MODE);
            else
                WscSendMessage(pAdapter, OpCode, WscData, DataLen, pWscControl, AP_MODE);
#endif // CONFIG_AP_SUPPORT //

        }
    }
	else
		bUPnPStatus = TRUE;
	
Fail:
    DBGPRINT(RT_DEBUG_TRACE, ("WscEapEnrolleeAction : rv = %d\n", rv));
    if (rv)
    {          
        switch(rv)
        {
            case WSC_ERROR_DEV_PWD_AUTH_FAIL:
                pWscControl->WscStatus = STATUS_WSC_ERROR_DEV_PWD_AUTH_FAIL;
                pWscControl->RegData.EnrolleeInfo.ConfigError = WSC_ERROR_DEV_PWD_AUTH_FAIL;
                break;
            default:
                pWscControl->WscStatus = STATUS_WSC_FAIL;
                pWscControl->RegData.EnrolleeInfo.ConfigError = WSC_ERROR_DECRYPT_CRC_FAIL;
                break;
        }
		if (bUPnPMsg)
		{
			if (pWscUPnPInfo->bUPnPMsgTimerRunning == TRUE)
			{
            	RTMPCancelTimer(&pWscUPnPInfo->UPnPMsgTimer, &Cancelled);
	            pWscUPnPInfo->bUPnPMsgTimerRunning = FALSE;
			}
			pWscUPnPInfo->bUPnPInProgress = FALSE;
		}
		else
        {
            DataLen = BuildMessageNACK(pAdapter, pWscControl, WscData);            
#ifdef CONFIG_AP_SUPPORT
            if (pEntry->ValidAsApCli)
                WscSendMessage(pAdapter, WSC_OPCODE_NACK, WscData, DataLen, pWscControl, AP_CLIENT_MODE);
            else
                WscSendMessage(pAdapter, WSC_OPCODE_NACK, WscData, DataLen, pWscControl, AP_MODE);
            pEntry->bWscCapable = FALSE;
#endif // CONFIG_AP_SUPPORT //


            RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
            pWscControl->EapolTimerRunning = FALSE;
            pWscControl->RegData.ReComputePke = 1;
        }
#ifdef CONFIG_AP_SUPPORT
        pWscControl->WscState = WSC_STATE_OFF;
#endif // CONFIG_AP_SUPPORT //


        pWscControl->EntryApIdx = WSC_INIT_ENTRY_APIDX;
        pWscControl->WscMode = 1;

        bUPnPStatus = FALSE;
    }

Done:
	if(WscData)
		kfree(WscData);
	if(bUPnPMsg && (bUPnPStatus == FALSE))
		WscUPnPErrHandle(pAdapter, pWscControl, Elem->TimeStamp.u.LowPart);
		
#ifdef CONFIG_AP_SUPPORT
    if (  ((bUPnPMsg || (pEntry && pEntry->ValidAsCLI)) && pWscControl->WscState == WSC_STATE_CONFIGURED) 
#ifdef APCLI_SUPPORT        
        ||((!bUPnPMsg && pEntry && pEntry->ValidAsApCli) && (pWscControl->WscState == WSC_STATE_WAIT_EAPFAIL || pWscControl->WscState == WSC_STATE_CONFIGURED))
#endif // APCLI_SUPPORT //        
       )
#endif // CONFIG_AP_SUPPORT //
    {
        pWscControl->bWscTrigger = FALSE;
        if (pWscControl->Wsc2MinsTimerRunning)
    	{
    		pWscControl->Wsc2MinsTimerRunning = FALSE;
    		RTMPCancelTimer(&pWscControl->Wsc2MinsTimer, &Cancelled);
    	}
        if (pWscControl->WscConfStatus == WSC_SCSTATE_UNCONFIGURED)
        {
            pAdapter->WriteWscCfgToDatFile = TRUE;
            pWscControl->WscStatus = STATUS_WSC_CONFIGURED;
            pWscControl->WscConfStatus = WSC_SCSTATE_CONFIGURED;
            pWscControl->WscMode = 1;

#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
            if (!bUPnPMsg && pEntry && pEntry->ValidAsApCli)
            {
                WscWriteConfToApCliCfg(pAdapter, pEntry, TRUE);
            }
            else
#endif // APCLI_SUPPORT //
                WscWriteConfToPortCfg(pAdapter, pEntry, TRUE);

            if (bUPnPMsg || (pEntry && pEntry->ValidAsCLI))
                up(&(pAdapter->write_dat_file_semaphore));
            
            if (bUPnPMsg || (pEntry && pEntry->ValidAsCLI))
            {
                WscBuildBeaconIE(pAdapter, WSC_SCSTATE_CONFIGURED, FALSE, 0, 0);
    		    WscBuildProbeRespIE(pAdapter, WSC_MSGTYPE_AP_WLAN_MGR, WSC_SCSTATE_CONFIGURED, FALSE, 0, 0);
                
                APStop(pAdapter);
            	APStartUp(pAdapter);
            }
#endif // CONFIG_AP_SUPPORT //


        }
    }
}

#ifdef CONFIG_AP_SUPPORT
VOID WscEapApProxyAction(
	IN	PRTMP_ADAPTER	pAdapter, 
	IN	MLME_QUEUE_ELEM	*Elem,
	IN  UCHAR	        MsgType,
	IN  MAC_TABLE_ENTRY *pEntry,
	IN  PWSC_CTRL       pWscControl)
{
	PUCHAR  WscData = NULL;
	BOOLEAN sendToUPnP = FALSE, bUPnPStatus = FALSE, Cancelled;
	int reqID = 0;
    WSC_UPNP_NODE_INFO *pWscUPnPInfo = &pWscControl->WscUPnPNodeInfo;
		
    DBGPRINT(RT_DEBUG_TRACE, ("WscEapApProxyAction Enter!\n"));

	if (Elem->MsgType == WSC_EAPOL_UPNP_MSG)
	{	
		reqID = Elem->TimeStamp.u.LowPart;
		if(reqID > 0)
			sendToUPnP = TRUE;
	}

	DBGPRINT(RT_DEBUG_TRACE, ("WscEapApProxyAction():pEntry=%p, ElemMsgType=%ld, MsgType=%d!\n", pEntry, Elem->MsgType, MsgType));
 
	if ((gWscActionMode != WSC_PROXY) || 
	   ((Elem->MsgType == WSC_EAPOL_PACKET_MSG) && (pEntry == NULL)))
//	   ((Elem->MsgType == WSC_EAPOL_UPNP_MSG) && (pEntry == NULL) && (MsgType!= WSC_MSG_EAP_RSP_ID)))
	{	
		DBGPRINT(RT_DEBUG_TRACE, ("EarlyCheckFailed: gWscActionMode=%d, pEntry=%p!\n", gWscActionMode, pEntry));
		goto Fail;
	}

	if ((WscData = kmalloc(WSC_MAX_DATA_LEN, GFP_ATOMIC)) == NULL)
	{
		DBGPRINT(RT_DEBUG_TRACE, ("WscData Allocate failed!\n"));
		goto Fail;
	}
	memset(WscData, 0, WSC_MAX_DATA_LEN);

    /* Base on state doing the Msg, State change diagram */
    if (Elem->MsgType == WSC_EAPOL_UPNP_MSG)
    {	// WSC message send from UPnP.
		switch (MsgType)
		{
			case WSC_MSG_M2:
			case WSC_MSG_M4:
			case WSC_MSG_M6:
			case WSC_MSG_M8:
	            DBGPRINT(RT_DEBUG_TRACE, ("WscEapApProxyAction: Rx WSC Msg(%d) from UPnP, eventID=0x%x!\n", MsgType, reqID));
				WscSendMessage(pAdapter, WSC_OPCODE_MSG, Elem->Msg, Elem->MsgLen, pWscControl, AP_MODE);

				//Notify the UPnP daemon which remote registar is negotiating with enrollee.
				if (MsgType == WSC_MSG_M2)
				{
					pWscUPnPInfo->registrarID = Elem->TimeStamp.u.HighPart;
					DBGPRINT(RT_DEBUG_TRACE, ("%s():registrarID=0x%x!\n", __FUNCTION__, pWscUPnPInfo->registrarID));
					bUPnPStatus = WscSendUPnPMessage(pAdapter, WSC_OPCODE_UPNP_MGMT, WSC_UPNP_MGMT_SUB_REG_SELECT, (PUCHAR)(&pWscUPnPInfo->registrarID), 
									sizeof(UINT), 0, 0, NULL);
				}
				break;
				
			case WSC_MSG_M2D:
				DBGPRINT(RT_DEBUG_TRACE, ("WscEapApProxyAction: Rx WSC_M2D Msg(%d) from UPnP, eventID=0x%x!\n", MsgType, reqID));

				//If it's send by UPnP Action, response ok directly to remote UPnP Control Point!
				if (reqID > 0)
					bUPnPStatus = WscSendUPnPMessage(pAdapter, WSC_OPCODE_UPNP_DATA, WSC_UPNP_DATA_SUB_ACK, 0, 0, reqID, 0, NULL);

				//Send M2D to wireless station.
				WscSendMessage(pAdapter, WSC_OPCODE_MSG, Elem->Msg, Elem->MsgLen, pWscControl, AP_MODE);
				pWscUPnPInfo->M2DACKBalance++;
				if ((pWscUPnPInfo->registrarID == 0) && (pWscUPnPInfo->bUPnPM2DTimerRunning == FALSE))
				{
					// Add M2D timer used to trigger the EAPFail Packet!
					RTMPSetTimer(&pWscUPnPInfo->UPnPM2DTimer, WSC_UPNP_M2D_TIME_OUT);
					pWscUPnPInfo->bUPnPM2DTimerRunning = TRUE;
				}
				break;
				
			case WSC_MSG_WSC_NACK:
			default:
				DBGPRINT(RT_DEBUG_TRACE, ("Recv WSC Msg(%d) from UPnP, request EventID=%d! drop it!\n", MsgType, reqID));
				break;
		}
    }
	else	
	{	//WSC msg send from EAP.
		switch (MsgType)
		{
	        case WSC_MSG_M1:
			case WSC_MSG_M3:
			case WSC_MSG_M5:
			case WSC_MSG_M7:
	            DBGPRINT(RT_DEBUG_TRACE, ("WscEapApProxyAction: Rx WSC Msg(%d) from EAP\n", MsgType));
				//This msg send to event-based external registrar
				if (MsgType == WSC_MSG_M1)
                {            
					bUPnPStatus = WscSendUPnPMessage(pAdapter, WSC_OPCODE_UPNP_DATA, WSC_UPNP_DATA_SUB_TO_ALL, Elem->Msg, 
														Elem->MsgLen, 0, 0, &pWscControl->EntryAddr[0]);
                    pWscControl->WscState = WSC_STATE_SENT_M1;
                }
				else
					bUPnPStatus = WscSendUPnPMessage(pAdapter, WSC_OPCODE_UPNP_DATA, WSC_UPNP_DATA_SUB_TO_ALL, Elem->Msg, 
														Elem->MsgLen, 0, pWscUPnPInfo->registrarID, &pWscControl->EntryAddr[0]);
				
				break;
				
			case WSC_MSG_WSC_ACK:
				DBGPRINT(RT_DEBUG_TRACE, ("WscEapApProxyAction: Rx WSC_ACK from EAP\n"));

				// The M2D must appeared before the ACK, so we just need sub it when (pWscUPnPInfo->M2DACKBalance > 0)
				if (pWscUPnPInfo->M2DACKBalance > 0)
					pWscUPnPInfo->M2DACKBalance--;
				break;
				
			case WSC_MSG_WSC_DONE:
	            DBGPRINT(RT_DEBUG_TRACE, ("WscEapApProxyAction: Rx WSC_DONE from EAP\n"));
				
//	            if (pWscControl->WscState == WSC_STATE_WAIT_DONE)
				{
					DBGPRINT(RT_DEBUG_TRACE, ("WscEapApProxyAction: send WSC_DONE to UPnP Registrar!\n"));
					//Send msg to event-based external registrar
					bUPnPStatus = WscSendUPnPMessage(pAdapter, WSC_OPCODE_UPNP_DATA, WSC_UPNP_DATA_SUB_TO_ONE, Elem->Msg, Elem->MsgLen, 
														0, pWscUPnPInfo->registrarID, &pWscControl->EntryAddr[0]);
					//Reset the UPnP timer and status.
					if (pWscUPnPInfo->bUPnPM2DTimerRunning == TRUE)
					{
						RTMPCancelTimer(&pWscUPnPInfo->UPnPM2DTimer, &Cancelled);
						pWscUPnPInfo->bUPnPM2DTimerRunning = FALSE;
					}
					pWscUPnPInfo->M2DACKBalance = 0;
					pWscUPnPInfo->registrarID = 0;

					//Send EAPFail to wireless station to finish the whole process.
					WscSendEapFail(pAdapter);
	                
                    RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
                    pWscControl->EapolTimerRunning = FALSE;

	                pEntry->bWscCapable = FALSE;
	                pWscControl->EapMsgRunning = FALSE;
	                pWscControl->EntryApIdx = WSC_INIT_ENTRY_APIDX;
//	                pWscControl->WscState = WSC_STATE_OFF;

                    if (pWscControl->Wsc2MinsTimerRunning)
                	{
                		pWscControl->Wsc2MinsTimerRunning = FALSE;
                		RTMPCancelTimer(&pWscControl->Wsc2MinsTimer, &Cancelled);
                	}
				}
	            break;
				
			default:
				DBGPRINT(RT_DEBUG_TRACE, ("Recv WSC Msg(%d) from EAP , it's impossible, drop it!\n", MsgType));
				break;
		}
	}

Fail:
	if (WscData)
		kfree(WscData);
	if (sendToUPnP && (bUPnPStatus == FALSE))
    {
		DBGPRINT(RT_DEBUG_TRACE, ("Need to send UPnP but bUPnPStatus is false!MsgType=%d, regID=0x%x!\n", MsgType, reqID));
		WscUPnPErrHandle(pAdapter, pWscControl, reqID);
	}
		
}
#endif // CONFIG_AP_SUPPORT //

VOID WscEapRegistrarAction(
	IN	PRTMP_ADAPTER	pAdapter, 
	IN	MLME_QUEUE_ELEM	*Elem,
	IN  UCHAR	        MsgType,
	IN  MAC_TABLE_ENTRY *pEntry,
	IN  PWSC_CTRL       pWscControl)
{
    INT     DataLen = 0, rv = 0;
    UCHAR   OpCode = 0;
    UCHAR   *WscData = NULL;    
	BOOLEAN bUPnPMsg, bUPnPStatus = FALSE, Cancelled;
	WSC_UPNP_NODE_INFO *pWscUPnPInfo = &pWscControl->WscUPnPNodeInfo;
	
    DBGPRINT(RT_DEBUG_TRACE, ("WscEapRegistrarAction Enter!\n"));

	bUPnPMsg = Elem->MsgType == WSC_EAPOL_UPNP_MSG ? TRUE : FALSE;

	if(bUPnPMsg)
	{
		//printk("Receive a UPnP message in RegistrarAction()!\n");
		if(MsgType == WSC_MSG_M1)
		{	/* It's a M1 message, we may need to initialize our state machine. */
			if (gWscActionMode == WSC_REGISTRAR && pWscControl->EntryApIdx == WSC_INIT_ENTRY_APIDX &&
				pWscControl->WscState < WSC_STATE_WAIT_M1 && pWscUPnPInfo->bUPnPInProgress == FALSE)
			{
				pWscUPnPInfo->bUPnPInProgress = TRUE;
				//Set the WscState as "WSC_STATE_WAIT_RESP_ID" because UPnP start from this state.
				pWscControl->WscState = WSC_STATE_WAIT_M1;
				RTMPSetTimer(&pWscUPnPInfo->UPnPMsgTimer, WSC_UPNP_MSG_TIME_OUT);
				pWscUPnPInfo->bUPnPMsgTimerRunning = TRUE;
			}
		}
		OpCode = WSC_OPCODE_UPNP_MASK;
		
	} else {
	    if (pWscControl->EapolTimerRunning)
    	    pWscControl->EapolTimerRunning = FALSE;

	}

	if( (WscData = kmalloc(WSC_MAX_DATA_LEN, GFP_ATOMIC)) == NULL)
	{
		DBGPRINT(RT_DEBUG_TRACE, ("WscData Allocate failed!\n"));
		goto Fail;
	}
	memset(WscData, 0, WSC_MAX_DATA_LEN);
	
	// Base on state doing the Msg, State change diagram
	switch (MsgType)
	{
		case WSC_MSG_M1:
            DBGPRINT(RT_DEBUG_TRACE, ("WscEapRegistrarAction : Rx M1\n"));
            
			// Receive M1, if we are at WSC_STATE_WAIT_M1 start, process it immediately
			if (pWscControl->WscState == WSC_STATE_WAIT_M1)
			{
			    OpCode |= WSC_OPCODE_MSG;
                
				// Process M1
			    //pWscControl->WscStatus = STATUS_WSC_EAP_M1_RECEIVED;
				if ((rv=ProcessMessageM1(pAdapter, pWscControl, Elem->Msg, Elem->MsgLen, &pWscControl->RegData)))
                    goto Fail;
                else
                {
                    if (pWscControl->WscMode == 1 && pWscControl->WscPinCode == 0)
                    {
                        DataLen = BuildMessageM2D(pAdapter, pWscControl, WscData);
                        pWscControl->WscState = WSC_STATE_SENT_M2D;
                    }
                    else
                    {
        				DataLen = BuildMessageM2(pAdapter, pWscControl, WscData);
        				//pWscControl->WscStatus = STATUS_WSC_EAP_M2_SENT;
        				// Change the state to next one
        				pWscControl->WscState = WSC_STATE_WAIT_M3;
                    }
                }
			}
			break;
			
		case WSC_MSG_M3:
			// Receive M3
			DBGPRINT(RT_DEBUG_TRACE, ("WscEapRegistrarAction : Rx M3\n"));
			if (pWscControl->WscState == WSC_STATE_WAIT_M3)
			{
                pWscControl->WscStatus = STATUS_WSC_EAP_M3_RECEIVED;

    			if((rv = ProcessMessageM3(pAdapter, Elem->Msg, Elem->MsgLen, &pWscControl->RegData)))
                    goto Fail;
    			else
    			{
    			    OpCode |= WSC_OPCODE_MSG;
	    			DataLen = BuildMessageM4(pAdapter, pWscControl, WscData);
    				pWscControl->WscStatus = STATUS_WSC_EAP_M4_SENT;
					// Change the state to next one
					pWscControl->WscState = WSC_STATE_WAIT_M5;
				}
			}
			break;

		case WSC_MSG_M5:
            DBGPRINT(RT_DEBUG_TRACE, ("WscEapRegistrarAction : Rx M5\n"));
			if (pWscControl->WscState == WSC_STATE_WAIT_M5)
			{
                pWscControl->WscStatus = STATUS_WSC_EAP_M5_RECEIVED;

				if ((rv=ProcessMessageM5(pAdapter, pWscControl, Elem->Msg, Elem->MsgLen, &pWscControl->RegData)))
                    goto Fail;
                else
                {
                    OpCode |= WSC_OPCODE_MSG;
        			DataLen = BuildMessageM6(pAdapter, pWscControl, WscData);
        			pWscControl->WscStatus = STATUS_WSC_EAP_M6_SENT;
    				// Change the state to next one
    				pWscControl->WscState = WSC_STATE_WAIT_M7;
                }
			}
			break;
		case WSC_MSG_M7:
			DBGPRINT(RT_DEBUG_TRACE, ("WscEapRegistrarAction : Rx M7\n"));
			if (pWscControl->WscState == WSC_STATE_WAIT_M7)
			{
                pWscControl->WscStatus = STATUS_WSC_EAP_M7_RECEIVED;
				if ((rv=ProcessMessageM7(pAdapter, pWscControl, Elem->Msg, Elem->MsgLen, &pWscControl->RegData)))
                    goto Fail;
                else
                {
                    if (
#ifdef CONFIG_AP_SUPPORT                        
                         (pAdapter->OpMode == OPMODE_AP) || 
#endif // CONFIG_AP_SUPPORT //   
                         (0))
                    {
                        OpCode |= WSC_OPCODE_MSG;

            			DataLen = BuildMessageM8(pAdapter, pWscControl, WscData);
            			pWscControl->WscStatus = STATUS_WSC_EAP_M8_SENT;
        				// Change the state to next one
        				pWscControl->WscState = WSC_STATE_WAIT_DONE;
                    }
                }
			}
			break;

		case WSC_MSG_WSC_DONE:
			DBGPRINT(RT_DEBUG_TRACE, ("WscEapRegistrarAction : Rx DONE\n"));
			if (pWscControl->WscState == WSC_STATE_WAIT_DONE)
			{
#ifdef CONFIG_AP_SUPPORT
				pWscControl->WscStatus = STATUS_WSC_EAP_RAP_RSP_DONE_SENT;
                // Send EAP-Fail
                WscSendEapFail(pAdapter);
                pWscControl->WscStatus = STATUS_WSC_CONFIGURED;
#endif // CONFIG_AP_SUPPORT //
				// Change the state to OFF, regComplete
				pWscControl->WscState = WSC_STATE_CONFIGURED;

                pWscControl->EapMsgRunning = FALSE;
			}
			break;
		default:
			DBGPRINT(RT_DEBUG_TRACE, ("WscEapRegistrarAction : Unsupported Msg Type\n"));
			return;
	}

	if(OpCode > WSC_OPCODE_UPNP_MASK)
		bUPnPStatus = WscSendUPnPMessage(pAdapter, WSC_OPCODE_UPNP_DATA, WSC_UPNP_DATA_SUB_NORMAL, WscData, DataLen, 
											Elem->TimeStamp.u.LowPart, Elem->TimeStamp.u.HighPart, &pWscControl->EntryAddr[0]);
	else if(OpCode > 0 && OpCode < WSC_OPCODE_UPNP_MASK)
    {
#ifdef CONFIG_AP_SUPPORT
        if (pWscControl->WscState != WSC_STATE_CONFIGURED)
            WscSendMessage(pAdapter, OpCode, WscData, DataLen, pWscControl, AP_MODE);
#endif // CONFIG_AP_SUPPORT //

		    
    }
	else
		bUPnPStatus = TRUE;

	if(bUPnPMsg)
	{
		if(pWscControl->WscState == WSC_STATE_SENT_M2D)
		{	//After M2D, reset the status of State Machine.
			pWscControl->WscState = WSC_STATE_WAIT_UPNP_START;
			pWscUPnPInfo->bUPnPInProgress = FALSE;
		}
	}
Fail:
    DBGPRINT(RT_DEBUG_TRACE, ("WscEapRegistrarAction : rv = %d\n", rv));
    if (rv)
    {        
        switch(rv)
        {
            case WSC_ERROR_HASH_FAIL:
                pWscControl->WscStatus = STATUS_WSC_ERROR_HASH_FAIL;
                pWscControl->RegData.EnrolleeInfo.ConfigError = WSC_ERROR_HASH_FAIL;
                break;
            case WSC_ERROR_HMAC_FAIL:
                pWscControl->WscStatus = STATUS_WSC_ERROR_HMAC_FAIL;
                pWscControl->RegData.EnrolleeInfo.ConfigError = WSC_ERROR_HMAC_FAIL;
                break;
            default:
                pWscControl->WscStatus = STATUS_WSC_FAIL;
                pWscControl->RegData.EnrolleeInfo.ConfigError = WSC_ERROR_DECRYPT_CRC_FAIL;
                break;
        }        
        if (bUPnPMsg)
        {
			if (pWscUPnPInfo->bUPnPMsgTimerRunning == TRUE)
			{
            	RTMPCancelTimer(&pWscUPnPInfo->UPnPMsgTimer, &Cancelled);
	            pWscUPnPInfo->bUPnPMsgTimerRunning = FALSE;
			}
			pWscUPnPInfo->bUPnPInProgress = FALSE;
        }
		else
        {
            DataLen = BuildMessageNACK(pAdapter, pWscControl, WscData);            
#ifdef CONFIG_AP_SUPPORT
            WscSendMessage(pAdapter, WSC_OPCODE_NACK, WscData, DataLen, pWscControl, AP_MODE);
            pEntry->bWscCapable = FALSE;
#endif // CONFIG_AP_SUPPORT //


            RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
            pWscControl->EapolTimerRunning = FALSE;
        }
        /*
           If a PIN authentication or communication error occurs after sending message M6, 
           the Registrar MUST warn the user and MUST NOT automatically reuse the PIN. 
           Furthermore, if the Registrar detects this situation and prompts the user for a new PIN from the Enrollee device, 
           it MUST NOT accept the same PIN again without warning the user of a potential attack.
        */
        if (pWscControl->WscState >= WSC_STATE_WAIT_M7)
        {
            pWscControl->WscRejectSamePinFromEnrollee = TRUE;
            pWscControl->WscPinCode = 0;
        }
        pWscControl->WscState = WSC_STATE_OFF;
        pWscControl->WscStatus = STATUS_WSC_IDLE;
        pWscControl->EntryApIdx = WSC_INIT_ENTRY_APIDX;
        pWscControl->WscMode = 1;
        bUPnPStatus = FALSE;
    }

//Done:
	if(WscData)
		kfree(WscData);
	
	if(bUPnPMsg && (bUPnPStatus == FALSE))
		WscUPnPErrHandle(pAdapter, pWscControl, Elem->TimeStamp.u.LowPart);

    if (pWscControl->WscState == WSC_STATE_CONFIGURED)
    {
        pWscControl->bWscTrigger = FALSE;
        if (pWscControl->Wsc2MinsTimerRunning)
    	{
    		pWscControl->Wsc2MinsTimerRunning = FALSE;
    		RTMPCancelTimer(&pWscControl->Wsc2MinsTimer, &Cancelled);
    	}
		if (bUPnPMsg)
		{
			if (pWscUPnPInfo->bUPnPMsgTimerRunning == TRUE)
			{	RTMPCancelTimer(&pWscUPnPInfo->UPnPMsgTimer, &Cancelled);
            	pWscUPnPInfo->bUPnPMsgTimerRunning = FALSE;
			}
			pWscUPnPInfo->bUPnPInProgress = FALSE;
			pWscUPnPInfo->registrarID = 0;
		}
#ifdef CONFIG_AP_SUPPORT        
		else
		{
        	WscBuildBeaconIE(pAdapter, WSC_SCSTATE_CONFIGURED, FALSE, 0, 0);
			WscBuildProbeRespIE(pAdapter, WSC_MSGTYPE_AP_WLAN_MGR, WSC_SCSTATE_CONFIGURED, FALSE, 0, 0);
			APMakeAllBssBeacon(pAdapter);
			APUpdateAllBeaconFrame(pAdapter);
		}
        
        if (pWscControl->WscConfStatus == WSC_SCSTATE_UNCONFIGURED)
#endif // CONFIG_AP_SUPPORT //
        {
            pWscControl->WscConfStatus = WSC_SCSTATE_CONFIGURED;
            pAdapter->WriteWscCfgToDatFile = TRUE;
#ifdef CONFIG_AP_SUPPORT
            WscWriteConfToPortCfg(pAdapter, pEntry, FALSE);
            APStop(pAdapter);
        	APStartUp(pAdapter);
#endif // CONFIG_AP_SUPPORT //
            up(&(pAdapter->write_dat_file_semaphore));
        }
        pWscControl->WscPinCode = 0;
        pWscControl->WscMode = 1;
        RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
	    pWscControl->EapolTimerRunning = FALSE;
        return;
    }	
}

#ifdef CONFIG_AP_SUPPORT
VOID WscEnqueueEapolStart(
    IN PVOID SystemSpecific1, 
    IN PVOID FunctionContext, 
    IN PVOID SystemSpecific2, 
    IN PVOID SystemSpecific3) 
{
	MAC_TABLE_ENTRY     *pEntry = (PMAC_TABLE_ENTRY) FunctionContext;

	if ((pEntry) && (pEntry->EnqueueEapolStartTimerForWscRunning == TRUE))
	{
		RTMP_ADAPTER		*pAd = (PRTMP_ADAPTER)pEntry->pAd;

		pEntry->EnqueueEapolStartTimerForWscRunning = FALSE;	
		DBGPRINT(RT_DEBUG_TRACE, ("WscEAPOLTimeOutAction: Enqueue EAPOL-Start for %02x:%02x:%02x:%02x:%02x:%02x\n",
								pEntry->Addr[0], pEntry->Addr[1], pEntry->Addr[2],
    							pEntry->Addr[3], pEntry->Addr[4], pEntry->Addr[5]));

        MlmeEnqueue(pAd, WSC_STATE_MACHINE, WSC_EAPOL_START_MSG, 6, &pEntry->Addr);
	}				
}
#endif // CONFIG_AP_SUPPORT //

VOID WscTimeOutProcess(
    IN  PRTMP_ADAPTER       pAd,
    IN  PMAC_TABLE_ENTRY    pEntry,
    IN  INT                 nWscState,
    IN  PWSC_CTRL           pWscControl)
{
    INT         WscMode;

    if (nWscState == WSC_STATE_WAIT_ACK)
        pWscControl->WscState = WSC_STATE_CONFIGURED;
    else if (nWscState == WSC_STATE_WAIT_RESP_ID)
        pWscControl->WscState = WSC_STATE_OFF;
    else if (nWscState == WSC_STATE_RX_M2D)
    {
        pWscControl->WscState = WSC_STATE_FAIL;
        
#ifdef CONFIG_AP_SUPPORT        
        WscSendEapFail(pAd);
        MlmeEnqueue(pAd, WSC_STATE_MACHINE, WSC_EAPOL_START_MSG, 6, &pEntry->Addr);
#endif // CONFIG_AP_SUPPORT //        

        pWscControl->EapolTimerRunning = FALSE;
        pWscControl->WscRetryCount = 0;
        

        return;
    }
    else if (nWscState == WSC_STATE_WAIT_EAPFAIL)
    {
        pWscControl->WscState = WSC_STATE_OFF;
		pWscControl->WscStatus = STATUS_WSC_CONFIGURED;
        pWscControl->WscConfMode = WSC_DISABLE;
    }
    else
    {
#ifdef CONFIG_AP_SUPPORT    
        if (gWscActionMode == WSC_PROXY)
        {
    		pWscControl->WscState = WSC_STATE_OFF;
            //WscSendEapFail(pAd);
        }
    	else
#endif // CONFIG_AP_SUPPORT //            
    		pWscControl->WscState = WSC_STATE_FAIL;
    }  
    pWscControl->WscRetryCount = 0;
    pWscControl->EntryApIdx = WSC_INIT_ENTRY_APIDX;
    pWscControl->EapolTimerRunning = FALSE;
#ifdef CONFIG_AP_SUPPORT
    pWscControl->WscPinCode = 0;
#endif // CONFIG_AP_SUPPORT //
    //pWscControl->WscMode = 1;
    if (pWscControl->WscMode == 1)
		WscMode = DEV_PASS_ID_PIN;
	else
		WscMode = DEV_PASS_ID_PBC;	
    //pWscControl->bWscTrigger = FALSE;
    
#ifdef CONFIG_AP_SUPPORT
    pEntry->bWscCapable = FALSE;
    if (pEntry->ValidAsCLI &&
        (pWscControl->WscState > WSC_STATE_CONFIGURED))
    {
        WscSendEapFail(pAd);
        WscBuildBeaconIE(pAd, pWscControl->WscConfStatus, FALSE, WscMode, WSC_CONFIG_METHODS);
    	WscBuildProbeRespIE(pAd, WSC_MSGTYPE_AP_WLAN_MGR, pWscControl->WscConfStatus, FALSE, WscMode, WSC_CONFIG_METHODS);
    }
#endif // CONFIG_AP_SUPPORT //


    DBGPRINT(RT_DEBUG_TRACE, ("WscTimeOutProcess\n"));
}

VOID WscEAPOLTimeOutAction(
    IN PVOID SystemSpecific1, 
    IN PVOID FunctionContext, 
    IN PVOID SystemSpecific2, 
    IN PVOID SystemSpecific3)
{
#ifdef CONFIG_AP_SUPPORT
    INT                 DataLen = 0;
#endif // CONFIG_AP_SUPPORT //
    PUCHAR              WscData = NULL;
    PMAC_TABLE_ENTRY    pEntry = NULL;
    PWSC_CTRL           pWscControl = NULL;
    
    DBGPRINT(RT_DEBUG_TRACE, ("-----> WscEAPOLTimeOutAction\n"));
        
    if (FunctionContext == 0)
    {
        DBGPRINT(RT_DEBUG_INFO, ("data is NULL!!\n"));
        DBGPRINT(RT_DEBUG_INFO, ("<----- WscEAPOLTimeOutAction\n"));
        return;
    }
    else
    {
        pWscControl = (PWSC_CTRL)FunctionContext;
#ifdef CONFIG_AP_SUPPORT
        pEntry = MacTableLookup(pWscControl->pAd, pWscControl->EntryAddr);
#endif // CONFIG_AP_SUPPORT //
    }

#ifdef CONFIG_AP_SUPPORT
    if (pEntry == NULL)
    {
        pWscControl->EapolTimerRunning = FALSE;
        pWscControl->EntryApIdx = 0xFF;
        DBGPRINT(RT_DEBUG_TRACE, ("sta is left.\n"));
        DBGPRINT(RT_DEBUG_TRACE, ("<----- WscEAPOLTimeOutAction\n"));
        return;
    }
#endif // CONFIG_AP_SUPPORT //

    if (!pWscControl->EapolTimerRunning)
    {
        pWscControl->WscRetryCount = 0;
        goto out;
    }
    
    if (pWscControl->EapolTimerPending)
    {
        RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
        DBGPRINT(RT_DEBUG_TRACE, ("EapolTimer Pending......\n"));
        DBGPRINT(RT_DEBUG_TRACE, ("<----- WscEAPOLTimeOutAction\n"));
        return;
    }

    if ((WscData = kmalloc(WSC_MAX_DATA_LEN, GFP_ATOMIC))!= NULL)
        memset(WscData, 0, WSC_MAX_DATA_LEN);

#ifdef CONFIG_AP_SUPPORT
    if (pEntry->ValidAsCLI && pWscControl->WscState <= WSC_STATE_CONFIGURED )
    {
        // A timer in the AP should cause to be disconnected after 5 seconds if a 
        // valid EAP-Rsp/Identity indicating WPS is not received.
        // << from WPS EAPoL and RSN handling.doc >>
        WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_RESP_ID, pWscControl);
        //WscSendEapFail(pWscControl->pAd);

//      If do disassocation here, it will affect connection of non-WPS clients.        
//      DisAssocAction(pAd, pEntry, SUBTYPE_DISASSOC, REASON_RESERVED);
        goto out;
    }
#endif // CONFIG_AP_SUPPORT //

    switch(pWscControl->WscState)
    {
/*    
	   case WSC_STATE_WAIT_RESP_ID:
            // A timer in the AP should cause to be disconnected after 5 seconds if a 
            // valid EAP-Rsp/Identity indicating WPS is not received.
            // << from WPS EAPoL and RSN handling.doc >>
            WscTimeOutProcess(pAd, pEntry, WSC_STATE_WAIT_RESP_ID);
            WscSendEapFail(pAd);
            DisAssocAction(pAd, pEntry, SUBTYPE_DISASSOC, REASON_RESERVED);
			break;
*/
        case WSC_STATE_WAIT_REQ_ID:
            WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_REQ_ID, pWscControl);
            break;
        case WSC_STATE_WAIT_WSC_START:
		    WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_WSC_START, pWscControl);
            break;
        case WSC_STATE_WAIT_M1:
			if (pWscControl->WscRetryCount >= 2)
                WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_M1, pWscControl);
			else
			{
#ifdef CONFIG_AP_SUPPORT
                WscSendMessage(pWscControl->pAd, WSC_OPCODE_START, NULL, 0, pWscControl, AP_MODE); // Ap Client doesn't support Registrar. 20070521
#endif // CONFIG_AP_SUPPORT //
				pWscControl->WscRetryCount++;
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
            break;
	    case WSC_STATE_SENT_M1:
		    if (pWscControl->WscRetryCount >= 2)
                WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_M2, pWscControl);
			else
			{
			    if (gWscActionMode == WSC_ENROLLEE)
                {
                    {
#ifdef CONFIG_AP_SUPPORT
                        if (pEntry->ValidAsCLI)
                            WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_MODE);
                        else if (pEntry->ValidAsApCli)
                            WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_CLIENT_MODE);
#endif // CONFIG_AP_SUPPORT //

                    }
                }
				pWscControl->WscRetryCount++;
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
            break;
        case WSC_STATE_RX_M2D:
            if (pWscControl->WscRetryCount >= 2)
			    WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_RX_M2D, pWscControl);
			else
			{
				pWscControl->WscRetryCount++;
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
            break;
        case WSC_STATE_WAIT_PIN:
            if (pWscControl->WscRetryCount >= 2)
			    WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_PIN, pWscControl);
			else
			{
				pWscControl->WscRetryCount++;
                if (pWscControl->WscPinCode != 0)
                {
#ifdef CONFIG_AP_SUPPORT
                    WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_MODE);
#endif // CONFIG_AP_SUPPORT //

                    pWscControl->WscState = WSC_STATE_WAIT_M3;
                }
                else
                {
                    DBGPRINT(RT_DEBUG_TRACE, ("No PIN CODE, cannot send M2 out!\n"));
                }
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
            break;
        case WSC_STATE_WAIT_M3:
            if (pWscControl->WscRetryCount >= 2)
                WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_M3, pWscControl);
			else
			{
			    if (gWscActionMode == WSC_REGISTRAR)
                {
                    {
#ifdef CONFIG_AP_SUPPORT
                    WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_MODE);
#endif // CONFIG_AP_SUPPORT //

                    }
                }
				pWscControl->WscRetryCount++;
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
            break;
        case WSC_STATE_WAIT_M4:
            if (pWscControl->WscRetryCount >= 2)
			    WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_M4, pWscControl);
			else
			{
			    if (gWscActionMode == WSC_ENROLLEE)
                {
                    {
#ifdef CONFIG_AP_SUPPORT
                        if (pEntry->ValidAsCLI)
                            WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_MODE);
                        else if (pEntry->ValidAsApCli)
                            WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_CLIENT_MODE);
#endif // CONFIG_AP_SUPPORT //

                    }
                }
				pWscControl->WscRetryCount++;
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
            break;
        case WSC_STATE_WAIT_M5:
            if (pWscControl->WscRetryCount >= 2)
			    WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_M5, pWscControl);
			else
			{
			    if (gWscActionMode == WSC_REGISTRAR)
                {         
                    {
#ifdef CONFIG_AP_SUPPORT
                    WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_MODE);
#endif // CONFIG_AP_SUPPORT //

                    }
                }
				pWscControl->WscRetryCount++;
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
            break;
        case WSC_STATE_WAIT_M6:
            if (pWscControl->WscRetryCount >= 2)
                WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_M6, pWscControl);
			else
			{
			    if (gWscActionMode == WSC_ENROLLEE)
                {         
                    {
#ifdef CONFIG_AP_SUPPORT
                        if (pEntry->ValidAsCLI)
                            WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_MODE);
                        else if (pEntry->ValidAsApCli)
                            WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_CLIENT_MODE);
#endif // CONFIG_AP_SUPPORT //

                    }
                }
				pWscControl->WscRetryCount++;
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
            break;
        case WSC_STATE_WAIT_M7:
            if (pWscControl->WscRetryCount >= 2)
			    WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_M7, pWscControl);
			else
			{
			    if (gWscActionMode == WSC_REGISTRAR)
                {         
                    {
#ifdef CONFIG_AP_SUPPORT
                    WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_MODE);
#endif // CONFIG_AP_SUPPORT //

                    }
                }
				pWscControl->WscRetryCount++;
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
            break;
        case WSC_STATE_WAIT_M8:
            if (pWscControl->WscRetryCount >= 2)
			    WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_M8, pWscControl);
			else
			{
			    if (gWscActionMode == WSC_ENROLLEE)
                {
                    {
#ifdef CONFIG_AP_SUPPORT
                        if (pEntry->ValidAsCLI)
                            WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_MODE);
                        else if (pEntry->ValidAsApCli)
                            WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_CLIENT_MODE);
#endif // CONFIG_AP_SUPPORT //

                    }
                }
				pWscControl->WscRetryCount++;
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
			break;
		case WSC_STATE_WAIT_DONE:
            if (pWscControl->WscRetryCount >= 2)
                WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_DONE, pWscControl);
			else
			{
				if (gWscActionMode == WSC_REGISTRAR)
                {
                    {
#ifdef CONFIG_AP_SUPPORT
                    WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, pWscControl->RegData.LastTx.Data, pWscControl->RegData.LastTx.Length, pWscControl, AP_MODE);
#endif // CONFIG_AP_SUPPORT //

                    }
                }
				pWscControl->WscRetryCount++;
				RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_TIME_OUT);
			}
			break;
#ifdef CONFIG_AP_SUPPORT
        // Only AP_Enrollee needs to wait EAP_ACK
        case WSC_STATE_WAIT_ACK:
            if (pWscControl->WscRetryCount >= 2)
                WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_ACK, pWscControl);
            else
            {
                if (gWscActionMode == WSC_ENROLLEE && pEntry->ValidAsCLI)
                {
    			    DataLen = BuildMessageDONE(pWscControl->pAd, pWscControl, WscData);
                    WscSendMessage(pWscControl->pAd, WSC_OPCODE_MSG, WscData, DataLen, pWscControl, AP_MODE);
                }
                RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_MSG_ACK_TIME_OUT);
                pWscControl->WscRetryCount++;
			}
			break;
#endif // CONFIG_AP_SUPPORT //
        case WSC_STATE_WAIT_EAPFAIL:
            // Wait 2 seconds
            if (pWscControl->WscRetryCount >= 1)
                WscTimeOutProcess(pWscControl->pAd, pEntry, WSC_STATE_WAIT_EAPFAIL, pWscControl);
            else
            {
                RTMPModTimer(&pWscControl->EapolTimer, WSC_EAP_EAP_FAIL_TIME_OUT);
                pWscControl->WscRetryCount++;
			}
            break;
        default:
            break;
    }

out:
    if (WscData)
        kfree(WscData);

    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscEAPOLTimeOutAction\n"));
}

VOID Wsc2MinsTimeOutAction(
    IN PVOID SystemSpecific1, 
    IN PVOID FunctionContext, 
    IN PVOID SystemSpecific2, 
    IN PVOID SystemSpecific3)
{
    PWSC_CTRL       pWscControl = (PWSC_CTRL)FunctionContext;
#ifdef CONFIG_AP_SUPPORT
    INT				IsAPConfigured = pWscControl->WscConfStatus;
#endif // CONFIG_AP_SUPPORT //
    BOOLEAN         Cancelled;

    DBGPRINT(RT_DEBUG_TRACE, ("-----> Wsc2MinsTimeOutAction\n"));
    DBGPRINT(RT_DEBUG_TRACE, ("Wsc2MinsTimerRunning is %s\n", 
                             pWscControl->Wsc2MinsTimerRunning ? "TRUE, reset WscState to WSC_STATE_OFF":"FALSE"));
    if (pWscControl->Wsc2MinsTimerRunning)
    {
        pWscControl->bWscTrigger = FALSE;
        pWscControl->EapolTimerRunning = FALSE;
        RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
        

#ifdef CONFIG_AP_SUPPORT
        if (pWscControl->EntryApIdx != MIN_NET_DEVICE_FOR_APCLI)
        {
            //WscSendEapFail(pWscControl->pAd);
            WscBuildBeaconIE(pWscControl->pAd, IsAPConfigured, FALSE, 0, 0);
    		WscBuildProbeRespIE(pWscControl->pAd, WSC_MSGTYPE_AP_WLAN_MGR, IsAPConfigured, FALSE, 0, 0);
    		APMakeAllBssBeacon(pWscControl->pAd);
    		APUpdateAllBeaconFrame(pWscControl->pAd);
        }
        if ((pWscControl->WscConfMode & WSC_PROXY) == 0)
    	{   // Proxy mechanism is disabled                	    
            pWscControl->WscState = WSC_STATE_OFF;
            pWscControl->EntryApIdx = WSC_INIT_ENTRY_APIDX;
        }
#endif // CONFIG_AP_SUPPORT //

        pWscControl->WscRetryCount = 0;
		pWscControl->Wsc2MinsTimerRunning = FALSE;

        pWscControl->WscSelReg = 0;
        pWscControl->WscStatus = STATUS_WSC_IDLE; 
    }
    DBGPRINT(RT_DEBUG_TRACE, ("<----- Wsc2MinsTimeOutAction\n"));
}

/*
	========================================================================
	
	Routine Description:
		Classify EAP message type for enrolee

	Arguments:
		pAd         - NIC Adapter pointer
		Elem		- The EAP packet
		
	Return Value:
		Received EAP message type

	IRQL = DISPATCH_LEVEL
	
	Note:
		
	========================================================================
*/
UCHAR	WscRxMsgType(
	IN	PRTMP_ADAPTER		pAdapter,
	IN	PMLME_QUEUE_ELEM	pElem) 
{
	USHORT				Length;
	PUCHAR				pData;
	USHORT				WscType, WscLen;
    UCHAR	            id_data[] = {"hello"};
    UCHAR	            fail_data[] = {"EAP_FAIL"};
    UCHAR	            wsc_start[] = {"WSC_START"};
    UCHAR               regIdentity[] = {"WFA-SimpleConfig-Registrar"};
    UCHAR               enrIdentity[] = {"WFA-SimpleConfig-Enrollee"};

    if (pElem->Msg[0] == 'W' && pElem->Msg[1] == 'F' && pElem->Msg[2] == 'A')
    {
        // Eap-Rsp(Identity)
		if (memcmp(regIdentity, pElem->Msg, strlen(regIdentity)) == 0)
			return  WSC_MSG_EAP_REG_RSP_ID;
        else if (memcmp(enrIdentity, pElem->Msg, strlen(enrIdentity)) == 0)
			return  WSC_MSG_EAP_ENR_RSP_ID;
    }
    else if (NdisEqualMemory(id_data, pElem->Msg, pElem->MsgLen))
    {
        // Eap-Req/Identity(hello)
		return  WSC_MSG_EAP_REQ_ID;
    }
    else if (NdisEqualMemory(fail_data, pElem->Msg, pElem->MsgLen))
    {
        // Eap-Fail
		return  WSC_MSG_EAP_FAIL;
    }
    else if (NdisEqualMemory(wsc_start, pElem->Msg, pElem->MsgLen))
    {
        // Eap-Req(Wsc_Start)
        return WSC_MSG_EAP_REQ_START;
    }
    else
    {   // Eap-Esp(Messages)
        pData = pElem->Msg;
        Length = (USHORT)pElem->MsgLen;

        // the first TLV item in EAP Messages must be WSC_IE_VERSION
        NdisMoveMemory(&WscType, pData, 2);
        if (ntohs(WscType) != WSC_ID_VERSION)
            goto out;

        // Not Wsc Start, We have to look for WSC_IE_MSG_TYPE to classify M2 ~ M8, the remain size must large than 4
		while (Length > 4)
		{
			// arm-cpu has packet alignment issue, it's better to use memcpy to retrieve data
			NdisMoveMemory(&WscType, pData, 2);
			NdisMoveMemory(&WscLen,  pData + 2, 2);
			WscLen = ntohs(WscLen);
			if (ntohs(WscType) == WSC_ID_MSG_TYPE)
			{
				return(*(pData + 4));	// Found the message type
			}
			else
			{
				pData  += (WscLen + 4);
				Length -= (WscLen + 4);
			}
		}
    }

out:
	return  WSC_MSG_UNKNOWN;
}

/*
	========================================================================
	
	Routine Description:
		Classify WSC message type

	Arguments:
		EAPType		Value of EAP message type
		MsgType		Internal Message definition for MLME state machine
		
	Return Value:
		TRUE		Found appropriate message type
		FALSE		No appropriate message type

	IRQL = DISPATCH_LEVEL
	
	Note:
		All these constants are defined in wpa.h
		For supplicant, there is only EAPOL Key message avaliable
		
	========================================================================
*/
BOOLEAN	WscMsgTypeSubst(
	IN	UCHAR	EAPType,
	IN	UCHAR	EAPCode,
	OUT	INT		*MsgType)	
{
	switch (EAPType)
	{
		case EAPPacket:
			*MsgType = WSC_EAPOL_PACKET_MSG;
			break;
        case EAPOLStart:
            *MsgType = WSC_EAPOL_START_MSG;
			break;
		default:
			DBGPRINT(RT_DEBUG_TRACE, ("WscMsgTypeSubst : unsupported EAP Type(%d); \n", EAPType));
			return FALSE;		
	}	

	return TRUE;
}

/*
	========================================================================
	
	Routine Description:
		Init WSC MAC header

	Arguments:
		pAdapter	Pointer	to our adapter
		
	Return Value:
		None
		
	Note:
		
	========================================================================
*/
VOID	WscMacHeaderInit(
	IN		PRTMP_ADAPTER	pAdapter, 
	IN OUT	PHEADER_802_11	Hdr, 
	IN		PUCHAR			pAddr1,
	IN      PUCHAR          pBSSID,
	IN      BOOLEAN         bFromApCli)	
{
	NdisZeroMemory(Hdr,	sizeof(HEADER_802_11));
	Hdr->FC.Type = BTYPE_DATA;
#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
    if (bFromApCli)
        Hdr->FC.ToDs = 1;
    else
#endif // APCLI_SUPPORT //
    {
    	Hdr->FC.ToDs = 0;
        Hdr->FC.FrDs = 1;
    }
#endif // CONFIG_AP_SUPPORT //
	
	 //	Addr1: DA, Addr2: BSSID, Addr3:	SA	
	COPY_MAC_ADDR(&Hdr->Addr1, pAddr1);
#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
    if (bFromApCli)
    {
        COPY_MAC_ADDR(&Hdr->Addr2, &pAdapter->ApCfg.ApCliTab[0].CurrentAddress);
    }
    else
#endif // APCLI_SUPPORT //
#endif // CONFIG_AP_SUPPORT //
	    COPY_MAC_ADDR(&Hdr->Addr2, &pAdapter->CurrentAddress);
	COPY_MAC_ADDR(&Hdr->Addr3, pBSSID);
	Hdr->Sequence =	pAdapter->Sequence;		
}

VOID	WscInitRegistrarPair(
	IN	PRTMP_ADAPTER		pAdapter,
	IN  PWSC_CTRL           pWscControl)
{
	INT		idx;
#ifdef CONFIG_AP_SUPPORT   
    UCHAR	apidx = MAIN_MBSSID;
#endif // CONFIG_AP_SUPPORT //
	
	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscInitRegistrarPair\n"));
    gWscActionMode = 0;

	// 1. Version
	pWscControl->RegData.EnrolleeInfo.Version = WSC_VERSION;
	pWscControl->RegData.RegistrarInfo.Version = WSC_VERSION;

	// 2. UUID Enrollee, last 6 bytes use MAC
	NdisMoveMemory(&pWscControl->RegData.RegistrarInfo.Uuid[0], &pAdapter->Wsc_Uuid_E[0], UUID_LEN_HEX);
	NdisMoveMemory(&pWscControl->RegData.EnrolleeInfo.Uuid[0], &pAdapter->Wsc_Uuid_E[0], UUID_LEN_HEX);

	// 3. MAC address
#ifdef CONFIG_AP_SUPPORT	
	NdisMoveMemory(pWscControl->RegData.EnrolleeInfo.MacAddr, pAdapter->ApCfg.MBSSID[apidx].Bssid, 6);
#endif // CONFIG_AP_SUPPORT //

	// 4. Device Name
	NdisMoveMemory(&pWscControl->RegData.EnrolleeInfo.DeviceName, WSC_DEVICE_NAME, sizeof(WSC_DEVICE_NAME));
	
	// 5. Manufacture
	NdisMoveMemory(&pWscControl->RegData.EnrolleeInfo.Manufacturer, WSC_MANUFACTURE, sizeof(WSC_MANUFACTURE));

	// 6. Model Name
	NdisMoveMemory(&pWscControl->RegData.EnrolleeInfo.ModelName, WSC_MODEL_NAME, sizeof(WSC_MODEL_NAME));
	
	// 7. Model Number
	NdisMoveMemory(&pWscControl->RegData.EnrolleeInfo.ModelNumber, WSC_MODEL_NUMBER, sizeof(WSC_MODEL_NUMBER));
	
	// 8. Serial Number
	NdisMoveMemory(&pWscControl->RegData.EnrolleeInfo.SerialNumber, WSC_MODEL_SERIAL, sizeof(WSC_MODEL_SERIAL));
	
	// 9. Authentication Type Flags
	// Open(=1), WPAPSK(=2),Shared(=4), WPA2PSK(=20),WPA(=8),WPA2(=10)
	// (0x01 | 0x02 | 0x04 | 0x20 | 0x08 | 0x10) = 0x3F
	// WCN vista logo will check this flags.
	pWscControl->RegData.EnrolleeInfo.AuthTypeFlags = cpu2be16(0x003F);
	pWscControl->RegData.RegistrarInfo.AuthTypeFlags = cpu2be16(0x003F);
	
	// 10. Encryption Type Flags
	// None(=1), WEP(=2), TKIP(=4), AES(=8)
	// (0x01 | 0x02 | 0x04 | 0x08) = 0x0F
	pWscControl->RegData.EnrolleeInfo.EncrTypeFlags  = cpu2be16(0x000F);
	pWscControl->RegData.RegistrarInfo.EncrTypeFlags  = cpu2be16(0x000F);
	
	// 11. Connection Type Flag
	pWscControl->RegData.EnrolleeInfo.ConnTypeFlags = 0x01;					// ESS

	// 12. Associate state
	pWscControl->RegData.EnrolleeInfo.AssocState = cpu2be16(0x0000);		// Not associated

	// 13. Configure Error
	pWscControl->RegData.EnrolleeInfo.ConfigError = cpu2be16(0x0000);		// No error

	// 14. OS Version
	pWscControl->RegData.EnrolleeInfo.OsVersion = cpu2be32(0x80000000);		// first bit must be 1
	
	// 15. RF Band
	if ((pAdapter->CommonCfg.PhyMode == PHY_11A) || (pAdapter->CommonCfg.PhyMode == PHY_11AN_MIXED))
    {   
	    pWscControl->RegData.EnrolleeInfo.RfBand = WSC_RFBAND_50GHZ;	// 5G
	    pWscControl->RegData.RegistrarInfo.RfBand = WSC_RFBAND_50GHZ;	// 5G
    }   
    else
    {
        pWscControl->RegData.EnrolleeInfo.RfBand = WSC_RFBAND_24GHZ;	// 2.4G
        pWscControl->RegData.RegistrarInfo.RfBand = WSC_RFBAND_24GHZ;	// 2.4G
    }

	// 16. Config Method
	// TODO: Might need to differ between PBC and PIN mode
	pWscControl->RegData.EnrolleeInfo.ConfigMethods = cpu2be16(0x008c);		// Label, Display, PBC

	// 17. Simple Config State
#ifdef CONFIG_AP_SUPPORT
	pWscControl->RegData.EnrolleeInfo.ScState = pWscControl->WscConfStatus;
#endif // CONFIG_AP_SUPPORT //
	pWscControl->RegData.RegistrarInfo.ScState = pWscControl->WscConfStatus;

	// 18. Device Password ID
	if (pWscControl->WscMode == WSC_PIN_MODE)
	{
		pWscControl->RegData.EnrolleeInfo.DevPwdId = cpu2be16(DEV_PASS_ID_PIN);		// PIN mode
	}
	else
	{
		pWscControl->RegData.EnrolleeInfo.DevPwdId = cpu2be16(DEV_PASS_ID_PBC);		// PBC
	}

	// 19. SSID
#ifdef CONFIG_AP_SUPPORT
	NdisMoveMemory(pWscControl->RegData.EnrolleeInfo.Ssid, pAdapter->ApCfg.MBSSID[apidx].Ssid, pAdapter->ApCfg.MBSSID[apidx].SsidLen);
#endif // CONFIG_AP_SUPPORT //

	// 20. Primary Device Type
	NdisMoveMemory(&pWscControl->RegData.EnrolleeInfo.PriDeviceType, &Wsc_Pri_Dev_Type[0], 8);

	// Other enrollee controlled data in RegData structure
	
	// 1. Enrollee Nonce, first generate and save to Wsc Control Block
	for (idx = 0; idx < 16; idx++)
	{
		pWscControl->RegData.SelfNonce[idx] = RandomByte(pAdapter);
        pWscControl->RegData.EnrolleeNonce[idx] = pWscControl->RegData.SelfNonce[idx];
        pWscControl->RegData.RegistrarNonce[idx] = pWscControl->RegData.SelfNonce[idx];
	}

	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscInitRegistrarPair\n"));	
}

#ifdef CONFIG_AP_SUPPORT
VOID WscInitEntryFunc(
    IN  PMAC_TABLE_ENTRY pEntry)
{
    DBGPRINT(RT_DEBUG_TRACE, ("-----> WscInitEntryFunc\n"));

    if (pEntry)
    {
        RTMP_ADAPTER	*pAd = (PRTMP_ADAPTER)pEntry->pAd;

        pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryApIdx = pEntry->apidx;
        NdisZeroMemory(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, MAC_ADDR_LEN);
        NdisMoveMemory(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, pEntry->Addr, MAC_ADDR_LEN);
        pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscRetryCount = 0;
    }

    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscInitEntryFunc\n"));	
}
#endif // CONFIG_AP_SUPPORT //

BOOLEAN WscCheckWSCHeader(
    IN	PRTMP_ADAPTER		pAdapter,
    IN  PUCHAR              pData)
{
    PWSC_FRAME			pWsc;

	pWsc = (PWSC_FRAME) pData;

    // Verify SMI first
	if (((pWsc->SMI[0] * 256 + pWsc->SMI[1]) * 256 + pWsc->SMI[2]) != WSC_SMI)
	{
		// Wrong WSC SMI Vendor ID, Update WSC status
		//pAdapter->ApCfg.MBSSID[apidx].WscControl.WscStatus = STATUS_WSC_EAP_RSP_WRONG_SMI;				
		return  FALSE;
	}
    
    // Verify Vendor Type
	if (cpu2be32(pWsc->VendorType) != WSC_VENDOR_TYPE)
	{
		// Wrong WSC Vendor Type, Update WSC status
		//pAdapter->ApCfg.MBSSID[apidx].WscControl.WscStatus = STATUS_WSC_EAP_RSP_WRONG_VENDOR_TYPE;
		return  FALSE;
	}
    return TRUE;
}

#ifdef CONFIG_AP_SUPPORT
VOID	WscSendEapReqId(
	IN	PRTMP_ADAPTER		pAdapter,
	IN	PMAC_TABLE_ENTRY	pEntry)
{
	HEADER_802_11		Header_802_11;
	USHORT				Length;
	IEEE8021X_FRAME		Ieee_8021x;
	EAP_FRAME			EapFrame;
	UCHAR				*OutBuffer = NULL;
	ULONG				FrameLen = 0;
	UCHAR				EAPHEAD[8] = {0xaa,	0xaa, 0x03,	0x00, 0x00,	0x00, 0x88, 0x8e};
    UCHAR				Data[] = "hello";
    UCHAR				Id;
	
	// 1. Send EAP-Rsp Id
	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscSendEapReqId\n"));

	// =====================================
	// Use Priority Ring & MiniportMMRequest
	// =====================================
	pAdapter->Sequence = ((pAdapter->Sequence) + 1)	& (MAX_SEQ_NUMBER);
    
	WscMacHeaderInit(pAdapter, 
                     &Header_802_11, 
                     pEntry->Addr,
                     pAdapter->ApCfg.MBSSID[pEntry->apidx].Bssid,
                     FALSE);

	// Length, -1 NULL pointer of string
	Length = sizeof(EAP_FRAME) + sizeof(Data) - 1;
	
	// Zero 802.1x body
	NdisZeroMemory(&Ieee_8021x, sizeof(Ieee_8021x));
	Ieee_8021x.Version = EAPOL_VER;
	Ieee_8021x.Type    = EAPPacket;
	Ieee_8021x.Length  = cpu2be16(Length);

	// Zero EAP frame
	NdisZeroMemory(&EapFrame, sizeof(EapFrame));
    /* RFC 3748 Ch 4.1: recommended to initalize Identifier with a
	 * random number */
	Id = RandomByte(pAdapter);
    if (Id == pAdapter->ApCfg.MBSSID[pEntry->apidx].WscControl.lastId)
        Id += 1;
	EapFrame.Code   = EAP_CODE_REQ;
	EapFrame.Id     = Id;
	EapFrame.Length = cpu2be16(Length);
	EapFrame.Type   = EAP_TYPE_ID;
    pAdapter->ApCfg.MBSSID[pEntry->apidx].WscControl.lastId = Id;
	
    // Out buffer for transmitting EAP-Req(Identity)
    OutBuffer = kmalloc(MAX_LEN_OF_MLME_BUFFER, MEM_ALLOC_FLAG);
    if(OutBuffer == NULL)
        return;

	FrameLen = 0;
	
	// Make	 Transmitting frame
	MakeOutgoingFrame(OutBuffer, &FrameLen,	sizeof(HEADER_802_11), &Header_802_11,
		sizeof(EAPHEAD), EAPHEAD, sizeof(IEEE8021X_FRAME), &Ieee_8021x,
		sizeof(EapFrame), &EapFrame, (sizeof(Data) - 1), Data,
		END_OF_ARGS);

	// Send using priority queue
	MiniportMMRequest(pAdapter, QID_AC_BE, OutBuffer, FrameLen);

	// Update WSC status
	//pAdapter->ApCfg.MBSSID[pEntry->apidx].WscControl.WscStatus = STATUS_WSC_EAP_REQ_ID_SENT;	
    kfree(OutBuffer);
	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscSendEapReqId\n"));	
}
#endif // CONFIG_AP_SUPPORT //

/*
	========================================================================
	
	Routine Description:
		Send EAPoL-Start packet to AP.

	Arguments:
		pAd         - NIC Adapter pointer
		
	Return Value:
		None
		
	IRQL = DISPATCH_LEVEL
	
	Note:
		Actions after link up
		1. Change the correct parameters
		2. Send EAPOL - START
		
	========================================================================
*/
VOID    WscSendEapolStart(
	IN	PRTMP_ADAPTER	pAdapter,
	IN  PUCHAR          pBssid,
	IN  BOOLEAN         bFromApCli)
{
	HEADER_802_11		Header_802_11;
	UCHAR				AckRate = RATE_2;
	USHORT				AckDuration = 0;
	IEEE8021X_FRAME		Packet;
	UCHAR				*OutBuffer = NULL;
	NDIS_STATUS			NStatus;
	ULONG				FrameLen = 0;
	UCHAR				EAPHEAD[8] = {0xaa,	0xaa, 0x03,	0x00, 0x00,	0x00,0x88,0x8e};
	
	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscSendEapolStart\n"));

	// 1. Change the authentication to open and encryption to none if necessary.

	// 2. Send EAPOL start
	
	// =====================================
	// Use Priority Ring & MiniportMMRequest
	// =====================================
	pAdapter->Sequence = ((pAdapter->Sequence) + 1)	& (MAX_SEQ_NUMBER);

    WscMacHeaderInit(pAdapter, &Header_802_11, pBssid, pBssid, bFromApCli);

	// ACK size	is 14 include CRC, and its rate	is based on real time information
	AckRate = pAdapter->CommonCfg.ExpectedACKRate[pAdapter->CommonCfg.TxRate];
	AckDuration = RTMPCalcDuration(pAdapter, AckRate, 14);
	Header_802_11.Duration = pAdapter->CommonCfg.Dsifs + AckDuration;
	
	// Zero message 2 body
	NdisZeroMemory(&Packet, sizeof(Packet));
	Packet.Version = EAPOL_VER;
	Packet.Type    = EAPOLStart;
	Packet.Length  = cpu2be16(0);
	
	// Out buffer for transmitting message 2		
	NStatus = MlmeAllocateMemory(pAdapter, (PVOID)&OutBuffer);  //Get an unused nonpaged memory
	if (NStatus	!= NDIS_STATUS_SUCCESS)	
		return;					

	FrameLen = 0;
	// Make	 Transmitting frame
	MakeOutgoingFrame(OutBuffer, &FrameLen,	sizeof(HEADER_802_11), &Header_802_11,
		sizeof(EAPHEAD), EAPHEAD, 
		4, &Packet,
		END_OF_ARGS);

    // Send using priority queue
	MiniportMMRequest(pAdapter, QID_AC_BE, OutBuffer, FrameLen);

#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
	// Update WSC status
	pAdapter->ApCfg.ApCliTab[0].WscControl.WscStatus = STATUS_WSC_EAPOL_START_SENT;
    pAdapter->ApCfg.ApCliTab[0].WscControl.WscStatus = WSC_STATE_WAIT_REQ_ID;
    if (!pAdapter->ApCfg.ApCliTab[0].WscControl.EapolTimerRunning)
    {
        pAdapter->ApCfg.ApCliTab[0].WscControl.EapolTimerRunning = TRUE;
        RTMPSetTimer(&pAdapter->ApCfg.ApCliTab[0].WscControl.EapolTimer, WSC_EAPOL_START_TIME_OUT);
    }
#endif // APCLI_SUPPORT //
#endif // CONFIG_AP_SUPPORT //


	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscSendEapolStart\n"));
}

VOID	WscSendEapRspId(
	IN	PRTMP_ADAPTER		pAdapter,
	IN  PMAC_TABLE_ENTRY    pEntry,
	IN  PWSC_CTRL           pWscControl)
{
	HEADER_802_11		Header_802_11;
	USHORT				Length = 0;
	IEEE8021X_FRAME		Ieee_8021x;
	EAP_FRAME			EapFrame;
	UCHAR				*OutBuffer = NULL;
	ULONG				FrameLen = 0;
	UCHAR				EAPHEAD[8] = {0xaa,	0xaa, 0x03,	0x00, 0x00,	0x00, 0x88, 0x8e};
    UCHAR               regIdentity[] = "WFA-SimpleConfig-Registrar-1-0";
    UCHAR               enrIdentity[] = "WFA-SimpleConfig-Enrollee-1-0";
	
	// 1. Send EAP-Rsp Id
	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscSendEapRspId\n"));

	// =====================================
	// Use Priority Ring & MiniportMMRequest
	// =====================================
	pAdapter->Sequence = ((pAdapter->Sequence) + 1)	& (MAX_SEQ_NUMBER);

#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
    WscMacHeaderInit(pAdapter, &Header_802_11, pEntry->Addr, pEntry->Addr, TRUE);
    Length = sizeof(EAP_FRAME) + sizeof(enrIdentity) - 1;
    pWscControl->WscConfMode = WSC_ENROLLEE; // Ap Client only support Enrollee now. 20070518
#endif // APCLI_SUPPORT //
#endif // CONFIG_AP_SUPPORT //

   	
	// Zero 802.1x body
	NdisZeroMemory(&Ieee_8021x, sizeof(Ieee_8021x));
	Ieee_8021x.Version = EAPOL_VER;
	Ieee_8021x.Type    = EAPPacket;
	Ieee_8021x.Length  = cpu2be16(Length);

	// Zero EAP frame
	NdisZeroMemory(&EapFrame, sizeof(EapFrame));
	EapFrame.Code   = EAP_CODE_RSP;
	EapFrame.Id     = pWscControl->lastId;
	EapFrame.Length = cpu2be16(Length);
	EapFrame.Type   = EAP_TYPE_ID;

    // Out buffer for transmitting EAP-Req(Identity)
    OutBuffer = kmalloc(MAX_LEN_OF_MLME_BUFFER, MEM_ALLOC_FLAG);
    if(OutBuffer == NULL)
        return;

	FrameLen = 0;

    if (pWscControl->WscConfMode == WSC_REGISTRAR)
    {
    	// Make	 Transmitting frame
    	MakeOutgoingFrame(OutBuffer, &FrameLen,	sizeof(HEADER_802_11), &Header_802_11,
    		sizeof(EAPHEAD), EAPHEAD, sizeof(IEEE8021X_FRAME), &Ieee_8021x,
    		sizeof(EapFrame), &EapFrame, (sizeof(regIdentity) - 1), regIdentity,
    		END_OF_ARGS);
    }
    else if (pWscControl->WscConfMode == WSC_ENROLLEE)
    {
        // Make	 Transmitting frame
    	MakeOutgoingFrame(OutBuffer, &FrameLen,	sizeof(HEADER_802_11), &Header_802_11,
    		sizeof(EAPHEAD), EAPHEAD, sizeof(IEEE8021X_FRAME), &Ieee_8021x,
    		sizeof(EapFrame), &EapFrame, (sizeof(enrIdentity) - 1), enrIdentity,
    		END_OF_ARGS);
    }
    else
    {
        DBGPRINT(RT_DEBUG_TRACE, ("WscConfMode(%d) is not WSC_REGISTRAR nor WSC_ENROLLEE.\n", pWscControl->WscConfMode));	
        goto out;
    }

	// Send using priority queue
	MiniportMMRequest(pAdapter, QID_AC_BE, OutBuffer, FrameLen);	

    // Update WSC status
	//pAdapter->ApCfg.MBSSID[pEntry->apidx].WscControl.WscStatus = STATUS_WSC_EAP_REQ_ID_SENT;

    if (!pWscControl->EapolTimerRunning)
    {
        pWscControl->EapolTimerRunning = TRUE;
        RTMPSetTimer(&pWscControl->EapolTimer, WSC_EAP_ID_TIME_OUT);
    }
out:
    kfree(OutBuffer);
	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscSendEapRspId\n"));	
}

VOID WscUPnPErrHandle(
	IN PRTMP_ADAPTER pAd,
	IN  PWSC_CTRL		pWscControl,
	IN UINT eventID)
{
	int dataLen;
	UCHAR *pWscData;

	DBGPRINT(RT_DEBUG_TRACE, ("Into WscUPnPErrHandle, send WSC_OPCODE_UPNP_CTRL with eventID=0x%x!\n", eventID));
	//WscSendUPnPMessage(pAd, WSC_OPCODE_UPNP_CTRL, 0, NULL, 0, eventID, 0);

	if( (pWscData = kmalloc(WSC_MAX_DATA_LEN, GFP_ATOMIC)))
	{
		memset(pWscData, 0, WSC_MAX_DATA_LEN);
	
		dataLen = BuildMessageNACK(pAd, pWscControl, pWscData);
		WscSendUPnPMessage(pAd, WSC_OPCODE_UPNP_DATA, WSC_UPNP_DATA_SUB_NORMAL, pWscData, dataLen, eventID, 0, NULL);
	
		kfree(pWscData);
	} 
	else 
	{
		WscSendUPnPMessage(pAd, WSC_OPCODE_UPNP_CTRL, 0, NULL, 0, eventID, 0, NULL);
	}
}

/*
	Format of iwcustom msg WSC clientJoin message:
		1. SSID which station want to probe(32 bytes):
			<SSID string>
			*If the length if SSID string is small than 32 bytes, fill 0x0 for remaining bytes.
		2. sender MAC address(6 bytes):
		3. Status:
			Set as 1 means change APStatus as 1. 
			Set as 2 means change STAStatus as 1.
			Set as 3 means trigger msg.
								
			32         6        1 
		+----------+--------+------+
		|SSIDString| SrcMAC |Status|
*/
int WscSendUPnPConfReqMsg(
	IN PRTMP_ADAPTER pAd,
	IN PUCHAR ssidStr,
	IN PUCHAR macAddr,
	IN INT	  Status,
	IN UINT   eventID)
{
	UCHAR pData[39] = {0};
	
	strncpy(pData, ssidStr, strlen(ssidStr));
	NdisMoveMemory(&pData[32], macAddr, MAC_ADDR_LEN);
	pData[38] = Status;
	WscSendUPnPMessage(pAd, WSC_OPCODE_UPNP_MGMT, WSC_UPNP_MGMT_SUB_CONFIG_REQ, &pData[0], 39, eventID, 0, NULL);

	return 0;
}

	
/*
	NETLINK tunnel msg format send to WSCUPnP handler in user space:
	1. Signature of following string(Not include the quote, 8 bytes)
			"RAWSCMSG"
	2. eID: eventID (4 bytes)
			the ID of this message(4 bytes)
	3. aID: ackID (4 bytes)
			means that which event ID this mesage was response to.
	4. TL:  Message Total Length (4 bytes) 
			Total length of this message.
	5. F:   Flag (2 bytes)
			used to notify some specific character of this msg segment.
				Bit 1: fragment
					set as 1 if netlink layer have more segment of this Msg need to send.
				Bit 2~15: reserve, should set as 0 now.
	5. SL:  Segment Length(2 bytes)
			msg actual length in this segment, The SL may not equal the "TL" field if "F" ==1
	6. "WSC_MSG" info:

          8        4     4    4   2  2     variable length(MAXIMA=232)
	+------------+----+----+----+--+--+------------------------------+
	|  Signature |eID |aID | TL |F |SL|            WSC_MSG           |

*/
int WscSendUPnPMessage(
	IN	PRTMP_ADAPTER		pAd, 
	IN  USHORT              msgType,
	IN  USHORT				msgSubType,
	IN  PUCHAR				pData,
	IN  INT					dataLen,
	IN	UINT				eventID,
	IN  UINT				toIPAddr,
	IN  PUCHAR				pMACAddr)
{
	union iwreq_data wrqu;
	RTMP_WSC_NLMSG_HDR *pNLMsgHdr;
	RTMP_WSC_MSG_HDR *pWscMsgHdr;
	
	UCHAR hdrBuf[36]; //RTMP_WSC_NLMSG_HDR_LEN + RTMP_WSC_MSG_HDR_LEN
	int totalLen, leftLen, copyLen;
	PUCHAR pBuf = NULL, pBufPtr = NULL, pPos = NULL;
	
	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscSendUPnPMessage\n"));

	if ((msgType & WSC_OPCODE_UPNP_MASK) != WSC_OPCODE_UPNP_MASK)
		return FALSE;
		
	//Prepare the NLMsg header
	memset(hdrBuf, 0, sizeof(hdrBuf));
	pNLMsgHdr = (RTMP_WSC_NLMSG_HDR *)hdrBuf;
	memcpy(pNLMsgHdr, WSC_MSG_SIGNATURE, RTMP_WSC_NLMSG_SIGNATURE_LEN);

	pNLMsgHdr->envID = jiffies;
	pNLMsgHdr->ackID = eventID;
	pNLMsgHdr->msgLen = dataLen + RTMP_WSC_MSG_HDR_LEN;

#ifdef MULTIPLE_CARD_SUPPORT
	NdisMoveMemory(&pNLMsgHdr->devAddr[0],  &pAd->CurrentAddress[0], MAC_ADDR_LEN);
#endif // MULTIPLE_CARD_SUPPORT //

	//Prepare the WscMsg header
	pWscMsgHdr = (RTMP_WSC_MSG_HDR *)(hdrBuf + sizeof(RTMP_WSC_NLMSG_HDR));
	switch(msgType)
	{
		case WSC_OPCODE_UPNP_DATA:
				pWscMsgHdr->msgType = WSC_OPCODE_UPNP_DATA;
				break;
		case WSC_OPCODE_UPNP_MGMT:
				pWscMsgHdr->msgType = WSC_OPCODE_UPNP_MGMT;
				break;
		case WSC_OPCODE_UPNP_CTRL:
				pWscMsgHdr->msgType = WSC_OPCODE_UPNP_CTRL;
				break;
		default:
				return FALSE;
	}
	pWscMsgHdr->msgSubType = msgSubType;
	pWscMsgHdr->ipAddr = toIPAddr;
	pWscMsgHdr->msgLen = dataLen;
	
	if ((pWscMsgHdr->msgType == WSC_OPCODE_UPNP_DATA) && 
		(eventID == 0) &&
		(pMACAddr != NULL) && 
		(NdisEqualMemory(pMACAddr, ZERO_MAC_ADDR, MAC_ADDR_LEN) == FALSE))
	{
		pWscMsgHdr->msgSubType |= WSC_UPNP_DATA_SUB_INCLUDE_MAC;
		pNLMsgHdr->msgLen += MAC_ADDR_LEN;
		pWscMsgHdr->msgLen += MAC_ADDR_LEN;
	}
	
//+++Add for debug
#if 0
{
	int i;
	char *tmp = pData;
	
	printk("\nDump the pData payload(msgType=%d, msgSubType=%d, toIPAddr=0x%x, dataLen=%d):\n", msgType, msgSubType, toIPAddr, dataLen);
	for(i=0;i< dataLen; i++)
	{
		if(i % 16==0 && i!=0)
			printk("\n");
		printk("%02x ", tmp[i] & 0xff);
	}							
	printk("\n------DumpFinished!\n");
}
#endif
//---Add for debug

	//Allocate memory and copy the msg.
	totalLen = leftLen = pNLMsgHdr->msgLen;
	pPos = pData;
	if((pBuf = kmalloc(IWEVCUSTOM_MSG_MAX_LEN, GFP_ATOMIC)) != NULL)
	{
		int firstSeg = 1;
	
		while(leftLen)
		{
			//Prepare the payload 
			memset(pBuf, 0, IWEVCUSTOM_MSG_MAX_LEN);

			pNLMsgHdr->segLen = (leftLen > IWEVCUSTOM_PAYLOD_MAX_LEN ? IWEVCUSTOM_PAYLOD_MAX_LEN : leftLen);
			leftLen -= pNLMsgHdr->segLen;
			pNLMsgHdr->flags = (leftLen > 0 ? 1 : 0);

			memcpy(pBuf, pNLMsgHdr, RTMP_WSC_NLMSG_HDR_LEN);
			pBufPtr = &pBuf[RTMP_WSC_NLMSG_HDR_LEN];

			if(firstSeg){
				memcpy(pBufPtr, pWscMsgHdr, RTMP_WSC_MSG_HDR_LEN);
				pBufPtr += RTMP_WSC_MSG_HDR_LEN;
				copyLen = (pNLMsgHdr->segLen - RTMP_WSC_MSG_HDR_LEN);
				if ((pWscMsgHdr->msgSubType & WSC_UPNP_DATA_SUB_INCLUDE_MAC) == WSC_UPNP_DATA_SUB_INCLUDE_MAC)
				{
					NdisMoveMemory(pBufPtr, pMACAddr, MAC_ADDR_LEN);
					pBufPtr += MAC_ADDR_LEN;
					copyLen -= MAC_ADDR_LEN;
				}
				NdisMoveMemory(pBufPtr, pPos, copyLen);
				pPos += copyLen;
				firstSeg = 0;
			} else {
				NdisMoveMemory(pBufPtr, pPos, pNLMsgHdr->segLen);
				pPos += pNLMsgHdr->segLen;
			}
			//Prepare the wreq msg header.
			memset(&wrqu, 0, sizeof(wrqu));
			wrqu.data.length = pNLMsgHdr->segLen + sizeof(RTMP_WSC_NLMSG_HDR);
						
			//Send WSC Msg to wscd
			wireless_send_event(pAd->net_dev, IWEVCUSTOM, &wrqu, pBuf);
		}
		
		kfree(pBuf);
	}

	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscSendUPnPMessage\n"));
	return TRUE;
}


VOID	WscSendMessage(
	IN	PRTMP_ADAPTER		pAdapter, 
	IN  UCHAR               OpCode,
	IN  PUCHAR				pData,
	IN  INT					Len,
	IN  PWSC_CTRL           pWscControl,
    IN  UCHAR               OpMode)
{
	// Send message
	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscSendMessage\n"));

    {
        // Inb-EAP Message
        HEADER_802_11		Header_802_11;
    	USHORT				Length;
    	IEEE8021X_FRAME		Ieee_8021x;
    	EAP_FRAME			EapFrame;
    	WSC_FRAME			WscFrame;
    	UCHAR				*OutBuffer = NULL;
        ULONG				FrameLen = 0;
	    UCHAR				EAPHEAD[8] = {0xaa,	0xaa, 0x03,	0x00, 0x00,	0x00, 0x88, 0x8e};
    
    	// =====================================
    	// Use Priority Ring & MiniportMMRequest
    	// =====================================
    	pAdapter->Sequence = ((pAdapter->Sequence) + 1)	& (MAX_SEQ_NUMBER);

#ifdef CONFIG_AP_SUPPORT
        if (OpMode == AP_MODE)
            WscMacHeaderInit(pAdapter, 
                             &Header_802_11,
                             pWscControl->EntryAddr,
                             pAdapter->ApCfg.MBSSID[0].Bssid,
                             FALSE);
        else if (OpMode == AP_CLIENT_MODE)
            WscMacHeaderInit(pAdapter, 
                             &Header_802_11,
                             pWscControl->EntryAddr,
                             pWscControl->EntryAddr,
                             TRUE);
#endif // CONFIG_AP_SUPPORT //

    	// Length = EAP + WSC_Frame + Payload
    	Length = sizeof(EAP_FRAME) + sizeof(WSC_FRAME) + Len;
    	
    	// Zero 802.1x body
    	NdisZeroMemory(&Ieee_8021x, sizeof(Ieee_8021x));
    	Ieee_8021x.Version = EAPOL_VER;
    	Ieee_8021x.Type    = EAPPacket;
    	Ieee_8021x.Length  = cpu2be16(Length);

    	// Zero EAP frame
    	NdisZeroMemory(&EapFrame, sizeof(EapFrame));

        if (OpMode == AP_MODE)
        {
        	EapFrame.Code   = EAP_CODE_REQ;
        	EapFrame.Id     = ++(pWscControl->lastId);
        }
        else if (OpMode == AP_CLIENT_MODE)
        {
            EapFrame.Code   = EAP_CODE_RSP;
            EapFrame.Id     = pWscControl->lastId; // same as AP eap_req id
        }        
        else if (OpMode == STA_MODE)
        {
            EapFrame.Code   = EAP_CODE_RSP;
            EapFrame.Id     = pWscControl->lastId; // same as AP eap_req id
        }

    	EapFrame.Length = cpu2be16(Length);
    	EapFrame.Type   = EAP_TYPE_WSC;

    	// Zero WSC Frame
    	NdisZeroMemory(&WscFrame, sizeof(WscFrame));
    	WscFrame.SMI[0] = 0x00;
    	WscFrame.SMI[1] = 0x37;
    	WscFrame.SMI[2] = 0x2A;
    	WscFrame.VendorType = cpu2be32(WSC_VENDOR_TYPE);
    	WscFrame.OpCode = OpCode;
    	WscFrame.Flags  = 0x00;

        // Out buffer for transmitting message
        OutBuffer = kmalloc(MAX_LEN_OF_MLME_BUFFER, MEM_ALLOC_FLAG);
        if(OutBuffer == NULL)
            return;

    	FrameLen = 0;
    	
    	// Make	 Transmitting frame
    	if (pData && (Len > 0))
        	MakeOutgoingFrame(OutBuffer, &FrameLen,	sizeof(HEADER_802_11), &Header_802_11,
        		sizeof(EAPHEAD), EAPHEAD, sizeof(IEEE8021X_FRAME), &Ieee_8021x,
        		sizeof(EapFrame), &EapFrame, sizeof(WscFrame), &WscFrame, Len, pData,
        		END_OF_ARGS);
        else
            MakeOutgoingFrame(OutBuffer, &FrameLen,	sizeof(HEADER_802_11), &Header_802_11,
        		sizeof(EAPHEAD), EAPHEAD, sizeof(IEEE8021X_FRAME), &Ieee_8021x,
        		sizeof(EapFrame), &EapFrame, sizeof(WscFrame), &WscFrame, END_OF_ARGS);

    	// Send using priority queue
    	MiniportMMRequest(pAdapter, QID_AC_BE, OutBuffer, FrameLen);
    	
    	kfree(OutBuffer);
    }
	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscSendMessage\n"));	
}

#ifdef CONFIG_AP_SUPPORT
/*
	========================================================================
	
	Routine Description:
		Ap send EAP-Fail to station

	Arguments:
		pAdapter    - NIC Adapter pointer
		Id			- ID between EAP-Req and EAP-Rsp pair
		pEntry		- The Station Entry information
		
	Return Value:
		None
		
	========================================================================
*/
VOID	WscSendEapFail(
	IN	PRTMP_ADAPTER		pAdapter)
{
	HEADER_802_11		Header_802_11;
	USHORT				Length;
	IEEE8021X_FRAME		Ieee_8021x;
	EAP_FRAME			EapFrame;
	UCHAR				*OutBuffer = NULL;
	ULONG				FrameLen = 0;
	UCHAR				apidx = MAIN_MBSSID;
	UCHAR				EAPHEAD[8] = {0xaa,	0xaa, 0x03,	0x00, 0x00,	0x00, 0x88, 0x8e};
	
	// 1. Send EAP-Rsp Id
	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscSendEapFail\n"));

	// =====================================
	// Use Priority Ring & MiniportMMRequest
	// =====================================
	pAdapter->Sequence = ((pAdapter->Sequence) + 1)	& (MAX_SEQ_NUMBER);
    
    WscMacHeaderInit(pAdapter, 
                     &Header_802_11,
                     pAdapter->ApCfg.MBSSID[apidx].WscControl.EntryAddr, 
                     pAdapter->ApCfg.MBSSID[apidx].Bssid,
                     FALSE);	

	// Length, -1 type size, Eap-Fail doesn't need Type item
	Length = sizeof(EAP_FRAME) - sizeof(UCHAR);
	
	// Zero 802.1x body
	NdisZeroMemory(&Ieee_8021x, sizeof(Ieee_8021x));
	Ieee_8021x.Version = EAPOL_VER;
	Ieee_8021x.Type    = EAPPacket;
	Ieee_8021x.Length  = cpu2be16(Length);

	// Zero EAP frame
	NdisZeroMemory(&EapFrame, sizeof(EapFrame));
	EapFrame.Code   = EAP_CODE_FAIL;
	EapFrame.Id     = pAdapter->ApCfg.MBSSID[apidx].WscControl.lastId;
	EapFrame.Length = cpu2be16(Length);
	
    // Out buffer for transmitting EAP-Req(Identity)
    OutBuffer = kmalloc(MAX_LEN_OF_MLME_BUFFER, MEM_ALLOC_FLAG);
    if(OutBuffer == NULL)
        return;

	FrameLen = 0;
	
	// Make	 Transmitting frame
	MakeOutgoingFrame(OutBuffer, &FrameLen,	sizeof(HEADER_802_11), &Header_802_11,
		sizeof(EAPHEAD), EAPHEAD, sizeof(IEEE8021X_FRAME), &Ieee_8021x,
		sizeof(EapFrame)-1, &EapFrame, END_OF_ARGS);

	// Send using priority queue
	MiniportMMRequest(pAdapter, QID_AC_BE, OutBuffer, FrameLen);

    pAdapter->ApCfg.MBSSID[apidx].WscControl.EntryApIdx = WSC_INIT_ENTRY_APIDX;
	// Update WSC status
	//pAdapter->ApCfg.MBSSID[apidx].WscControl.WscStatus = STATUS_WSC_EAP_FAIL_SENT;	
	kfree(OutBuffer);

	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscSendEapFail\n"));	
}

VOID WscBuildBeaconIE(
	IN	PRTMP_ADAPTER	pAd, 
	IN	UCHAR b_configured,
	IN	BOOLEAN b_selRegistrar,
	IN	USHORT devPwdId,
	IN	USHORT selRegCfgMethods)
{
	WSC_IE_HEADER 	ieHdr;
	UCHAR 			Data[256];
	PUCHAR			pData;
	INT				Len = 0, templen = 0;
	UCHAR			apidx = MAIN_MBSSID;
    USHORT          tempVal = 0;
	PWSC_REG_DATA	pReg = (PWSC_REG_DATA) &pAd->ApCfg.MBSSID[apidx].WscControl.RegData;
 
	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscBuildBeaconIE\n"));
	// WSC IE HEader
	ieHdr.elemId = 221;
	ieHdr.length = 4;
	ieHdr.oui[0] = 0x00; ieHdr.oui[1] = 0x50; 
    ieHdr.oui[2] = 0xF2; ieHdr.oui[3] = 0x04;

	pData = (PUCHAR) &Data[0];
	Len = 0;
	
	// 1. Version
	templen = AppendWSCTLV(WSC_ID_VERSION, pData, &pReg->RegistrarInfo.Version, 0);
	pData += templen;
	Len   += templen;

	// 2. Simple Config State
	templen = AppendWSCTLV(WSC_ID_SC_STATE, pData, (u8 *)&b_configured, 0);
	pData += templen;
	Len   += templen;
	
	if ( b_selRegistrar )
	{
		// 3.Selected Registrar
		templen = AppendWSCTLV(WSC_ID_SEL_REGISTRAR, pData, (u8 *)&b_selRegistrar, 0);
    	pData += templen;
    	Len   += templen;

		//4. Device Password ID
		tempVal = htons(devPwdId);
		templen = AppendWSCTLV(WSC_ID_DEVICE_PWD_ID, pData, (u8 *)&tempVal, 0);
    	pData += templen;
    	Len   += templen;

		// 5. Selected Registrar Config Methods
		tempVal = htons(selRegCfgMethods);
		templen = AppendWSCTLV(WSC_ID_SEL_REG_CFG_METHODS, pData, (u8 *)&tempVal, 0);
    	pData += templen;
    	Len   += templen;
	}

	// 6. UUID last 6 bytes use MAC
	templen = AppendWSCTLV(WSC_ID_UUID_E, pData, pReg->RegistrarInfo.Uuid, 0);
	pData += templen;
	Len   += templen;

	// 7. RF Bands
	templen = AppendWSCTLV(WSC_ID_RF_BAND, pData, (u8 *)&pReg->RegistrarInfo.RfBand, 0);
	pData += templen;
	Len   += templen;

	ieHdr.length = ieHdr.length + Len;
	memcpy(pAd->ApCfg.MBSSID[apidx].WscIEBeacon.Value, &ieHdr, sizeof(WSC_IE_HEADER));
	memcpy(pAd->ApCfg.MBSSID[apidx].WscIEBeacon.Value + sizeof(WSC_IE_HEADER), Data, Len);
	pAd->ApCfg.MBSSID[apidx].WscIEBeacon.ValueLen = sizeof(WSC_IE_HEADER) + Len;

	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscBuildBeaconIE\n"));
}

VOID WscBuildProbeRespIE(
	IN	PRTMP_ADAPTER	pAd, 
	IN	UCHAR respType,
	IN	UCHAR scState,
	IN	BOOLEAN b_selRegistrar,
	IN	USHORT devPwdId,
	IN	USHORT selRegCfgMethods)
{
	WSC_IE_HEADER 	ieHdr;
	UCHAR 			Data[512];
	PUCHAR			pData;
	INT				Len = 0, templen = 0;
	USHORT			tempVal = 0;
	UCHAR			apidx = MAIN_MBSSID;
    PWSC_REG_DATA	pReg = (PWSC_REG_DATA) &pAd->ApCfg.MBSSID[apidx].WscControl.RegData;

	DBGPRINT(RT_DEBUG_TRACE, ("-----> WscBuildProbeRespIE\n"));

	// WSC IE Header
	ieHdr.elemId = 221;
	ieHdr.length = 4;
	ieHdr.oui[0] = 0x00; ieHdr.oui[1] = 0x50;
    ieHdr.oui[2] = 0xF2; ieHdr.oui[3] = 0x04;

	pData = (PUCHAR) &Data[0];
	Len = 0;
	
	// 1. Version
	templen = AppendWSCTLV(WSC_ID_VERSION, pData, &pReg->RegistrarInfo.Version, 0);
	pData += templen;
	Len   += templen;

	// 2. Simple Config State
	templen = AppendWSCTLV(WSC_ID_SC_STATE, pData, (u8 *)&scState, 0);
	pData += templen;
	Len   += templen;

	if ( b_selRegistrar )
	{
		// 3. Selected Registrar
		templen = AppendWSCTLV(WSC_ID_SEL_REGISTRAR, pData, (u8 *)&b_selRegistrar, 0);
    	pData += templen;
    	Len   += templen;

		// 4. Device Password ID
		tempVal = htons(devPwdId);
		templen = AppendWSCTLV(WSC_ID_DEVICE_PWD_ID, pData, (u8 *)&tempVal, 0);
    	pData += templen;
    	Len   += templen;

		// 5. Selected Registrar Config Methods
		tempVal = htons(selRegCfgMethods);
		templen = AppendWSCTLV(WSC_ID_SEL_REG_CFG_METHODS, pData, (u8 *)&tempVal, 0);
    	pData += templen;
    	Len   += templen;
	}

	// 6. Response Type WSC_ID_RESP_TYPE
	templen = AppendWSCTLV(WSC_ID_RESP_TYPE, pData, (u8 *)&respType, 0);
   	pData += templen;
   	Len   += templen;

	// 7. UUID last 6 bytes use MAC
	templen = AppendWSCTLV(WSC_ID_UUID_E, pData, pReg->RegistrarInfo.Uuid, 0);
	pData += templen;
	Len   += templen;

	// 8. Manufacturer
	NdisZeroMemory(pData, 64 + 4);
    templen = AppendWSCTLV(WSC_ID_MANUFACTURER, pData,  pReg->EnrolleeInfo.Manufacturer, strlen(pReg->EnrolleeInfo.Manufacturer));
	pData += templen;
	Len   += templen;

	// 9. Model Name
	NdisZeroMemory(pData, 32 + 4);
    templen = AppendWSCTLV(WSC_ID_MODEL_NAME, pData, pReg->EnrolleeInfo.ModelName, strlen(pReg->EnrolleeInfo.ModelName));
	pData += templen;
	Len   += templen;

	// 10. Model Number
	NdisZeroMemory(pData, 32 + 4);
    templen = AppendWSCTLV(WSC_ID_MODEL_NUMBER, pData, pReg->EnrolleeInfo.ModelNumber, strlen(pReg->EnrolleeInfo.ModelNumber));
	pData += templen;
	Len   += templen;

	// 11. Serial Number
	NdisZeroMemory(pData, 32 + 4);
    templen = AppendWSCTLV(WSC_ID_SERIAL_NUM, pData, pReg->EnrolleeInfo.SerialNumber, strlen(pReg->EnrolleeInfo.SerialNumber));
	pData += templen;
	Len   += templen;

	// 12. Primary Device Type
	templen = AppendWSCTLV(WSC_ID_PRIM_DEV_TYPE, pData, pReg->EnrolleeInfo.PriDeviceType, 0);
	pData += templen;
	Len   += templen;

	// 13. Device Name
	NdisZeroMemory(pData, 32 + 4);
    templen = AppendWSCTLV(WSC_ID_DEVICE_NAME, pData, pReg->EnrolleeInfo.DeviceName, strlen(pReg->EnrolleeInfo.DeviceName));
	pData += templen;
	Len   += templen;

	// 14. Config Methods
	tempVal = htons(0x008a);
	templen = AppendWSCTLV(WSC_ID_CONFIG_METHODS, pData, (u8 *)&tempVal, 0);
	pData += templen;
	Len   += templen;

	// 15. RF Bands
	if ((pAd->CommonCfg.PhyMode == PHY_11A) || (pAd->CommonCfg.PhyMode == PHY_11AN_MIXED))
		tempVal = 2;
	else
		tempVal = 1;
    templen = AppendWSCTLV(WSC_ID_RF_BAND, pData, (u8 *)&tempVal, 0);
	pData += templen;
	Len   += templen;
     
	ieHdr.length = ieHdr.length + Len;
	memcpy(pAd->ApCfg.MBSSID[apidx].WscIEProbeResp.Value, &ieHdr, sizeof(WSC_IE_HEADER));
	memcpy(pAd->ApCfg.MBSSID[apidx].WscIEProbeResp.Value + sizeof(WSC_IE_HEADER), Data, Len);
	pAd->ApCfg.MBSSID[apidx].WscIEProbeResp.ValueLen = sizeof(WSC_IE_HEADER) + Len;

	DBGPRINT(RT_DEBUG_TRACE, ("<----- WscBuildProbeRespIE\n"));
}

VOID WscSelectedRegistrar(
	IN	PRTMP_ADAPTER	pAd,
	IN	PUCHAR	pReginfo,
	IN	UINT	Length)
{
	PUCHAR	pData;
	INT		IsAPConfigured;
	UCHAR   wsc_version, wsc_sel_reg = 0;
	USHORT	wsc_dev_pass_id = 0, wsc_sel_reg_conf_mthd = 0;
	USHORT	WscType, WscLen;
	UCHAR	apidx = MAIN_MBSSID;

	//if (gWscActionMode != WSC_PROXY)
	//	return;

	pData = (PUCHAR)pReginfo;

	if (Length < 4)
	{
		DBGPRINT(RT_DEBUG_TRACE, ("WscSelectedRegistrar --> Unknown IE \n"));
		return;
	}
	
	while (Length > 4)
	{
	    // arm-cpu has packet alignment issue, it's better to use memcpy to retrieve data
		NdisMoveMemory(&WscType, pData, 2);
		NdisMoveMemory(&WscLen,  pData + 2, 2);
		WscLen = ntohs(WscLen);
		pData  += 4;
		Length -= 4;
		switch (ntohs(WscType))
		{
			case WSC_ID_VERSION:
				wsc_version = *pData;
				break;

			case WSC_ID_SEL_REGISTRAR:
				wsc_sel_reg = *pData;
				break;

			case WSC_ID_DEVICE_PWD_ID:
				wsc_dev_pass_id = be2cpu16(*((PUSHORT) pData));
				break;

			case WSC_ID_SEL_REG_CFG_METHODS:
				wsc_sel_reg_conf_mthd = be2cpu16(*((PUSHORT) pData));
				break;

			default:
				DBGPRINT(RT_DEBUG_TRACE, ("WscSelectedRegistrar --> Unknown IE 0x%04x\n", WscType));
				break;
		}

		// Offset to net WSC Ie
		pData  += WscLen;
		Length -= WscLen;
	}

	IsAPConfigured = pAd->ApCfg.MBSSID[apidx].WscControl.WscConfStatus;

	if (wsc_sel_reg == 0x01)
	{
		pAd->ApCfg.MBSSID[apidx].WscControl.WscSelReg = 1;
		WscBuildBeaconIE(pAd, WSC_SCSTATE_CONFIGURED, TRUE, wsc_dev_pass_id, wsc_sel_reg_conf_mthd);
		WscBuildProbeRespIE(pAd, WSC_MSGTYPE_AP_WLAN_MGR, WSC_SCSTATE_CONFIGURED, TRUE, wsc_dev_pass_id, wsc_sel_reg_conf_mthd);
	}
	else
	{
		pAd->ApCfg.MBSSID[apidx].WscControl.WscSelReg = 0;
		WscBuildBeaconIE(pAd, WSC_SCSTATE_CONFIGURED, FALSE, 0, 0);
		WscBuildProbeRespIE(pAd, WSC_MSGTYPE_AP_WLAN_MGR, WSC_SCSTATE_CONFIGURED, FALSE, 0, 0);
	}

	APMakeAllBssBeacon(pAd);
	APUpdateAllBeaconFrame(pAd);
}
#endif // CONFIG_AP_SUPPORT //



INT ComputeChecksum(
	IN UINT PIN)
{
	INT digit_s;
    UINT accum = 0;

	PIN *= 10;
	accum += 3 * ((PIN / 10000000) % 10); 
	accum += 1 * ((PIN / 1000000) % 10); 
	accum += 3 * ((PIN / 100000) % 10); 
	accum += 1 * ((PIN / 10000) % 10); 
	accum += 3 * ((PIN / 1000) % 10); 
	accum += 1 * ((PIN / 100) % 10); 
	accum += 3 * ((PIN / 10) % 10); 

	digit_s = (accum % 10);
	return ((10 - digit_s) % 10);
} // ComputeChecksum

BOOLEAN ValidateChecksum(
	IN UINT PIN)
{
	UINT accum = 0;

	accum += 3 * ((PIN / 10000000) % 10); 
	accum += 1 * ((PIN / 1000000) % 10); 
	accum += 3 * ((PIN / 100000) % 10); 
	accum += 1 * ((PIN / 10000) % 10); 
	accum += 3 * ((PIN / 1000) % 10); 
	accum += 1 * ((PIN / 100) % 10); 
	accum += 3 * ((PIN / 10) % 10); 
	accum += 1 * ((PIN / 1) % 10); 
	
    return (0 == (accum % 10));
} // ValidateChecksum

UINT WscGeneratePinCode(
	IN	PRTMP_ADAPTER	pAd,
#ifdef CONFIG_AP_SUPPORT
    IN  BOOLEAN         bFromApcli,
#endif // CONFIG_AP_SUPPORT //	
	IN	UCHAR			apidx)
{
	UCHAR	macAddr[MAC_ADDR_LEN];
	UINT 	iPin;
	UINT	checksum;

#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
    if (bFromApcli)
        NdisMoveMemory(&macAddr[0], pAd->ApCfg.ApCliTab[apidx].CurrentAddress, MAC_ADDR_LEN);
    else
#endif // APCLI_SUPPORT //
	NdisMoveMemory(&macAddr[0], pAd->ApCfg.MBSSID[apidx].Bssid, MAC_ADDR_LEN);
#endif // CONFIG_AP_SUPPORT //

	iPin = macAddr[3] * 256 * 256 + macAddr[4] * 256 + macAddr[5];

	iPin = iPin % 10000000;
	checksum = ComputeChecksum( iPin );
	iPin = iPin*10 + checksum;

	return iPin;
}

UINT WscRandomGeneratePinCode(
	IN	PRTMP_ADAPTER	pAd,
	IN	UCHAR			apidx)
{
	UINT 	iPin;
	UINT	checksum;

	iPin = RandomByte(pAd) * 256 * 256 + RandomByte(pAd) * 256 + RandomByte(pAd);

	iPin = iPin % 10000000;
	checksum = ComputeChecksum( iPin );
	iPin = iPin*10 + checksum;

	return iPin;
}

#ifdef CONFIG_AP_SUPPORT
VOID  WscInformFromWPA(
    IN  PMAC_TABLE_ENTRY    pEntry)
{
    // WPA_STATE_MACHINE informs this Entry is already WPA_802_1X_PORT_SECURED.
    RTMP_ADAPTER	*pAd = (PRTMP_ADAPTER)pEntry->pAd;
    BOOLEAN         Cancelled;

    if (pEntry->apidx != MAIN_MBSSID)
        return;

    DBGPRINT(RT_DEBUG_TRACE, ("-----> WscInformFromWPA\n"));
    
    if (MAC_ADDR_EQUAL(pEntry->Addr, pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr))
    {
        pEntry->EnqueueEapolStartTimerForWscRunning = FALSE;
        RTMPCancelTimer(&pEntry->EnqueueEapolStartTimerForWsc, &Cancelled);
        
        pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryApIdx = WSC_INIT_ENTRY_APIDX;
        NdisZeroMemory(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, 6);
        RTMPCancelTimer(&pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EapolTimer, &Cancelled);
        pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EapolTimerRunning = FALSE;
        pEntry->bWscCapable = FALSE;
        pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.WscState = WSC_STATE_CONFIGURED;

        DBGPRINT(RT_DEBUG_TRACE, ("Reset EntryApIdx to %d\n", WSC_INIT_ENTRY_APIDX));
    }

    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscInformFromWPA\n"));
}

VOID WscDelWPARetryTimer(
    IN  PRTMP_ADAPTER pAd)
{
    PMAC_TABLE_ENTRY    pEntry;
    UCHAR				apidx = MAIN_MBSSID;
    BOOLEAN             Cancelled;

    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscDelWPARetryTimer\n"));
    
    pEntry = MacTableLookup(pAd, pAd->ApCfg.MBSSID[apidx].WscControl.EntryAddr);
    
    if (pEntry)
    {
        RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
        pEntry->WpaState = AS_NOTUSE;
    }

    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscDelWPARetryTimer\n"));
}
#endif // CONFIG_AP_SUPPORT //

VOID WscStop(
	IN	PRTMP_ADAPTER	pAd,
#ifdef CONFIG_AP_SUPPORT
    IN  BOOLEAN         bFromApCli,
#endif // CONFIG_AP_SUPPORT //
	IN  PWSC_CTRL       pWscControl)
{
	MAC_TABLE_ENTRY  *pEntry;
	PWSC_UPNP_NODE_INFO pWscUPnPInfo;
    BOOLEAN Cancelled;

#ifdef CONFIG_AP_SUPPORT	
	UCHAR	apidx = MAIN_MBSSID;
#endif // CONFIG_AP_SUPPORT //


	pWscUPnPInfo = &pWscControl->WscUPnPNodeInfo;
	
	if(pWscUPnPInfo->bUPnPMsgTimerRunning == TRUE)
	{
		pWscUPnPInfo->bUPnPMsgTimerRunning = FALSE;
		RTMPCancelTimer(&pWscUPnPInfo->UPnPMsgTimer, &Cancelled);
		pWscUPnPInfo->bUPnPMsgTimerPending = FALSE;
	}
	if(pWscUPnPInfo->bUPnPM2DTimerRunning)
	{
		pWscUPnPInfo->bUPnPM2DTimerRunning = FALSE;
		RTMPCancelTimer(&pWscUPnPInfo->UPnPM2DTimer, &Cancelled);
	}
	
    pWscUPnPInfo->bUPnPInProgress = FALSE;
    pWscUPnPInfo->M2DACKBalance = 0;
	pWscUPnPInfo->registrarID = 0;

	if (pWscControl->Wsc2MinsTimerRunning)
	{
		pWscControl->Wsc2MinsTimerRunning = FALSE;
		RTMPCancelTimer(&pWscControl->Wsc2MinsTimer, &Cancelled);
	}
	if (pWscControl->EntryApIdx != WSC_INIT_ENTRY_APIDX)
	{
	    pEntry = MacTableLookup(pAd, pWscControl->EntryAddr);
        
		RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
        pWscControl->EapolTimerRunning = FALSE;

#ifdef CONFIG_AP_SUPPORT
        if (pEntry && !bFromApCli) 
        {
            pEntry->bWscCapable = FALSE;
            if (pEntry->EnqueueEapolStartTimerForWscRunning)
            {
                RTMPCancelTimer(&pEntry->EnqueueEapolStartTimerForWsc, &Cancelled);
                pEntry->EnqueueEapolStartTimerForWscRunning = FALSE;
            }
        }
#endif // CONFIG_AP_SUPPORT //
        pWscControl->EntryApIdx = WSC_INIT_ENTRY_APIDX;
        NdisZeroMemory(pWscControl->EntryAddr, MAC_ADDR_LEN);
	}

	pWscControl->WscSelReg = 0;
    if ( (pWscControl->WscStatus != STATUS_WSC_CONFIGURED) ||
         (pWscControl->WscStatus != STATUS_WSC_FAIL) )
	    pWscControl->WscStatus = STATUS_WSC_NOTUSED;
	pWscControl->WscState = WSC_STATE_OFF;
	pWscControl->lastId = 1;
    pWscControl->EapMsgRunning = FALSE;
    pWscControl->EapolTimerPending = FALSE;
    pWscControl->bWscTrigger = FALSE;

	if (pWscControl->Wsc2MinsTimerRunning)
	{
		pWscControl->Wsc2MinsTimerRunning = FALSE;
		RTMPCancelTimer(&pWscControl->Wsc2MinsTimer, &Cancelled);
    }


#ifdef CONFIG_AP_SUPPORT

#ifdef APCLI_SUPPORT
    if (!bFromApCli)
#endif // APCLI_SUPPORT //
    {
    	pAd->ApCfg.MBSSID[apidx].WscIEBeacon.ValueLen = 0;
    	pAd->ApCfg.MBSSID[apidx].WscIEProbeResp.ValueLen = 0;
    }
#endif // CONFIG_AP_SUPPORT //
}

VOID WscInit(
	IN	PRTMP_ADAPTER	pAd,
#ifdef CONFIG_AP_SUPPORT
    IN  BOOLEAN         bFromApCli,
#endif // CONFIG_AP_SUPPORT //
	IN  PWSC_CTRL       pWscControl)
{
#ifdef CONFIG_AP_SUPPORT	
	INT IsAPConfigured;
#endif // CONFIG_AP_SUPPORT //

#ifdef OLD_DH_KEY
	if (pWscControl->pPubKeyMem)
		memset(pWscControl->pPubKeyMem, 0, 15 * MAX_NN_DIGITS + 1);
	if (pWscControl->pPubKeyMem)
		memset(pWscControl->pPubKeyMem, 0, 15 * MAX_NN_DIGITS + 1);
#endif //OLD_DH_KEY
	
    if (pWscControl->WscConfMode == WSC_DISABLE)
    {
#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
        if (!bFromApCli)
#endif // APCLI_SUPPORT //
        {
            pAd->ApCfg.MBSSID[MAIN_MBSSID].WscIEBeacon.ValueLen = 0;
            pAd->ApCfg.MBSSID[MAIN_MBSSID].WscIEProbeResp.ValueLen = 0;
        }
#endif // CONFIG_AP_SUPPORT //        
    }
    else
    {
        WscInitRegistrarPair(pAd, pWscControl);
        pWscControl->WscStatus = STATUS_WSC_IDLE;
#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
        if (!bFromApCli)
#endif // APCLI_SUPPORT //
        {
            IsAPConfigured = pWscControl->WscConfStatus;
        	WscBuildBeaconIE(pAd, IsAPConfigured, FALSE, 0, 0);
        	WscBuildProbeRespIE(pAd, WSC_MSGTYPE_AP_WLAN_MGR, IsAPConfigured, FALSE, 0, 0);

        	APMakeAllBssBeacon(pAd);
        	APUpdateAllBeaconFrame(pAd);
        }
#endif // CONFIG_AP_SUPPORT //        
    }
}

USHORT WscGetAuthType(
    IN NDIS_802_11_AUTHENTICATION_MODE authType)
{
	switch(authType)
	{
		case Ndis802_11AuthModeOpen:
			return WSC_AUTHTYPE_OPEN;
		case Ndis802_11AuthModeWPAPSK:
			return WSC_AUTHTYPE_WPAPSK;
		case Ndis802_11AuthModeShared:
			return WSC_AUTHTYPE_SHARED;
		case Ndis802_11AuthModeWPA:
			return WSC_AUTHTYPE_WPA;
		case Ndis802_11AuthModeWPA2:
			return WSC_AUTHTYPE_WPA2;
        default:
            if (authType == Ndis802_11AuthModeWPA1WPA2)
                return WSC_AUTHTYPE_WPA2;
		case Ndis802_11AuthModeWPA2PSK:
			return WSC_AUTHTYPE_WPA2PSK;
	}
}

USHORT WscGetEncryType(
    IN NDIS_802_11_WEP_STATUS encryType)
{
	switch(encryType)
	{
		case Ndis802_11WEPDisabled:
			return WSC_ENCRTYPE_NONE;
		case Ndis802_11WEPEnabled:
			return WSC_ENCRTYPE_WEP;        
		case Ndis802_11Encryption2Enabled:
			return WSC_ENCRTYPE_TKIP;
        default:
		case Ndis802_11Encryption3Enabled:
			return WSC_ENCRTYPE_AES;
	}
}

PCHAR   WscGetAuthTypeStr(
    IN  USHORT authFlag)
{
	switch(authFlag)
	{
		case WSC_AUTHTYPE_OPEN:
			return "OPEN";
        default:
		case WSC_AUTHTYPE_WPAPSK:
			return "WPAPSK";
		case WSC_AUTHTYPE_SHARED:
			return "SHARED";
		case WSC_AUTHTYPE_WPA:
			return "WPA";
		case WSC_AUTHTYPE_WPA2:
			return "WPA2";
		case WSC_AUTHTYPE_WPA2PSK:
			return "WPA2PSK";
	}
}

PCHAR   WscGetRalinkAuthModeStr(
    IN  NDIS_802_11_AUTHENTICATION_MODE authMode)
{
	switch(authMode)
	{
		case Ndis802_11AuthModeOpen:
			return "OPEN";
        default:
		case Ndis802_11AuthModeWPAPSK:
			return "WPAPSK";
		case Ndis802_11AuthModeShared:
			return "SHARED";
		case Ndis802_11AuthModeWPA:
			return "WPA";
		case Ndis802_11AuthModeWPA2:
			return "WPA2";
		case Ndis802_11AuthModeWPA2PSK:
			return "WPA2PSK";
        case Ndis802_11AuthModeWPA1PSKWPA2PSK:
			return "WPAPSKWPA2PSK";
        case Ndis802_11AuthModeWPA1WPA2:
			return "WPA1WPA2";
	}
}

PCHAR   WscGetEncryTypeStr(
    IN  USHORT encryFlag)
{
	switch(encryFlag)
	{
		case WSC_ENCRTYPE_NONE:
			return "NONE";
		case WSC_ENCRTYPE_WEP:
			return "WEP";
        default:
		case WSC_ENCRTYPE_TKIP:
			return "TKIP";
		case WSC_ENCRTYPE_AES:
			return "AES";
	}
}

PCHAR   WscGetRalinkEncryModeStr(
    IN  USHORT encryMode)
{
	switch(encryMode)
	{
	    default:
		case Ndis802_11WEPDisabled:
			return "NONE";
		case Ndis802_11WEPEnabled:
			return "WEP";        
		case Ndis802_11Encryption2Enabled:
			return "TKIP";
		case Ndis802_11Encryption3Enabled:
			return "AES";
        case Ndis802_11Encryption4Enabled:
			return "TKIPAES";
	}
}

void    WscWriteConfToPortCfg(
    IN  PRTMP_ADAPTER   pAd,
    IN  MAC_TABLE_ENTRY *pEntry,
    IN  BOOLEAN         bEnrollee)
{
    UCHAR               CurApIdx = MAIN_MBSSID;
    
#ifdef CONFIG_AP_SUPPORT
    PWSC_CREDENTIAL     pCredential;
#endif // CONFIG_AP_SUPPORT //
    PWSC_CTRL           pWscControl;

    DBGPRINT(RT_DEBUG_TRACE, ("-----> WscWriteConfToPortCfg\n"));
    
#ifdef CONFIG_AP_SUPPORT    
    if (pEntry)
        CurApIdx = pEntry->apidx;

    pWscControl = &pAd->ApCfg.MBSSID[CurApIdx].WscControl;
    pCredential = (PWSC_CREDENTIAL) &pWscControl->WscProfile.Profile[0];
#endif // CONFIG_AP_SUPPORT //


#ifdef CONFIG_AP_SUPPORT
    if (bEnrollee)
    {        
        NdisZeroMemory(pAd->ApCfg.MBSSID[CurApIdx].Ssid, MAX_LEN_OF_SSID);
    	NdisMoveMemory(pAd->ApCfg.MBSSID[CurApIdx].Ssid, pCredential->SSID.Ssid, pCredential->SSID.SsidLength);
    	pAd->ApCfg.MBSSID[CurApIdx].SsidLen = pCredential->SSID.SsidLength;
#endif // CONFIG_AP_SUPPORT //


        DBGPRINT(RT_DEBUG_TRACE, ("AuthType: %u, EncrType: %u\n", pCredential->AuthType, pCredential->EncrType));
        if ((pCredential->AuthType == WSC_AUTHTYPE_WPAPSK) || 
            (pCredential->AuthType == WSC_AUTHTYPE_WPA2PSK))
        {
            if ((pCredential->EncrType != WSC_ENCRTYPE_TKIP) && (pCredential->EncrType != WSC_ENCRTYPE_AES))
            {
                DBGPRINT(RT_DEBUG_TRACE, ("AuthType is WPAPSK or WPA2PAK.\n"
                                         "Get illegal EncrType(%d) from External Registrar, set EncrType to TKIP\n", 
                                          pCredential->EncrType));
                pCredential->EncrType = WSC_ENCRTYPE_TKIP;
            }
        }
        WscSetAuthMode(pAd, WscGetAuthTypeStr(pCredential->AuthType));
        WscSetEncrypType(pAd, WscGetEncryTypeStr(pCredential->EncrType));
        if (pCredential->EncrType != WSC_ENCRTYPE_NONE)
        {
            if ((pCredential->EncrType == WSC_ENCRTYPE_TKIP) ||
                (pCredential->EncrType == WSC_ENCRTYPE_AES))
            {
#ifdef CONFIG_AP_SUPPORT
                pAd->ApCfg.MBSSID[CurApIdx].DefaultKeyId = 1;
#endif // CONFIG_AP_SUPPORT //

                if (pCredential->KeyLength >= 8 && pCredential->KeyLength <= 64)
                {
                    pWscControl->WpaPskLen = pCredential->KeyLength;
                    memset(pWscControl->WpaPsk, 0, 64);
                    memcpy(pWscControl->WpaPsk, pCredential->Key, pWscControl->WpaPskLen);

                    if (pWscControl->WpaPskLen == 64)
                	{
#ifdef CONFIG_AP_SUPPORT
                	    AtoH(pWscControl->WpaPsk, pAd->ApCfg.MBSSID[CurApIdx].PMK, 32);
#endif // CONFIG_AP_SUPPORT //
                	}
                	else
                	{
                	    UCHAR       keyMaterial[40] = {0};
#ifdef CONFIG_AP_SUPPORT
                	    PasswordHash((CHAR *)pWscControl->WpaPsk, 
                                     pAd->ApCfg.MBSSID[CurApIdx].Ssid, pAd->ApCfg.MBSSID[CurApIdx].SsidLen, keyMaterial);
                	    NdisMoveMemory(pAd->ApCfg.MBSSID[CurApIdx].PMK, keyMaterial, 32);
#endif // CONFIG_AP_SUPPORT //

                	}
                    DBGPRINT(RT_DEBUG_TRACE, ("WpaPskLen = %d\n", pWscControl->WpaPskLen));
                }
                else
                {
                    pWscControl->WpaPskLen = 0;
                    DBGPRINT(RT_DEBUG_TRACE, ("WPAPSK: Invalid Key Length (%d)\n", pCredential->KeyLength));
                }
            }
            else if (pCredential->EncrType == WSC_ENCRTYPE_WEP)
            {
                CHAR   WepKeyId = 0;
                USHORT  WepKeyLen = pCredential->KeyLength;
                
				WepKeyId = (pCredential->KeyIndex - 1); // KeyIndex = 1 ~ 4
                
                if ((WepKeyId >= 0) && (WepKeyId <=3))
                {
#ifdef CONFIG_AP_SUPPORT                
                    pAd->ApCfg.MBSSID[CurApIdx].DefaultKeyId = WepKeyId;
#endif // CONFIG_AP_SUPPORT //

                    // 5 or 13 ASCII characters
                    // 10 or 26 Hex characters
                    if (WepKeyLen == 5 || WepKeyLen == 13 || WepKeyLen == 10 || WepKeyLen == 26)
                    {
                        if (WepKeyLen == 5 || WepKeyLen == 13)
                        {
                            pAd->SharedKey[CurApIdx][WepKeyId].KeyLen = WepKeyLen;
                            memcpy(pAd->SharedKey[CurApIdx][WepKeyId].Key, 
                                   pCredential->Key, 
                                   WepKeyLen);
                            if (WepKeyLen == 5)
                                pAd->SharedKey[CurApIdx][WepKeyId].CipherAlg = CIPHER_WEP64;
                            else
                                pAd->SharedKey[CurApIdx][WepKeyId].CipherAlg = CIPHER_WEP128;
                        }
                        else
                        {
                            pAd->SharedKey[CurApIdx][WepKeyId].KeyLen = WepKeyLen/2;
                            AtoH(pCredential->Key, pAd->SharedKey[CurApIdx][WepKeyId].Key, WepKeyLen/2);
                            if (WepKeyLen == 10)
                                pAd->SharedKey[CurApIdx][WepKeyId].CipherAlg = CIPHER_WEP64;
                            else
                                pAd->SharedKey[CurApIdx][WepKeyId].CipherAlg = CIPHER_WEP128;
                        }
                    }
                    else
                        DBGPRINT(RT_DEBUG_TRACE, ("WEP: Invalid Key Length (%d)\n", pCredential->KeyLength));
                }
                else
               	{
               		DBGPRINT(RT_DEBUG_TRACE, ("Unsupport default key index (%d)\n", WepKeyId));
#ifdef CONFIG_AP_SUPPORT
               		pAd->ApCfg.MBSSID[CurApIdx].DefaultKeyId = 0;
#endif // CONFIG_AP_SUPPORT //

                }
            }
        }
#ifdef CONFIG_AP_SUPPORT
    }
    else
    {
        pAd->ApCfg.MBSSID[CurApIdx].DefaultKeyId = 1;
        WscSetAuthMode(pAd, "WPAPSKWPA2PSK");
        WscSetEncrypType(pAd, "TKIPAES");
        pWscControl->WpaPskLen = pCredential->KeyLength;
        NdisZeroMemory(pWscControl->WpaPsk, 64);
        NdisMoveMemory(pWscControl->WpaPsk, pCredential->Key, pWscControl->WpaPskLen);
        AtoH(pWscControl->WpaPsk, pAd->ApCfg.MBSSID[CurApIdx].PMK, 32);
    }
#endif // CONFIG_AP_SUPPORT //

    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscWriteConfToPortCfg\n"));
}

void    WscWriteConfToDatFile(
    IN  PRTMP_ADAPTER pAd)
{
    PCHAR				fileName, cfgData = 0;
    struct file			*file_r, *file_w;
    INT 				orgfsuid, orgfsgid;
   	mm_segment_t		orgfs;
    ssize_t             rv, fileLen = 0;
    CHAR                *offset = 0;
    CHAR                *pTempStr = 0;
#ifdef CONFIG_AP_SUPPORT
    int                 index = 0;
    UCHAR				apidx = MAIN_MBSSID;
    PWSC_CTRL           pWscControl = &pAd->ApCfg.MBSSID[apidx].WscControl;
#endif // CONFIG_AP_SUPPORT //
    CHAR                WepKeyName[10] = {0};
    CHAR                WepKeyFormatName[10] = {0};

    DBGPRINT(RT_DEBUG_TRACE, ("-----> WscWriteConfToDatFile\n"));

    fileName = PROFILE_PATH;

    // Save uid and gid used for filesystem access.
	// Set user and group to 0 (root)	
	orgfsuid = current->fsuid;
	orgfsgid = current->fsgid;
	current->fsuid = current->fsgid = 0;    
	orgfs = get_fs();
    set_fs(KERNEL_DS);
    
#ifdef CONFIG_AP_SUPPORT
    sprintf(WepKeyName, "Key%dStr1=", pAd->ApCfg.MBSSID[MAIN_MBSSID].DefaultKeyId+1);
    sprintf(WepKeyFormatName, "Key%dType=", pAd->ApCfg.MBSSID[MAIN_MBSSID].DefaultKeyId+1);
#endif // CONFIG_AP_SUPPORT //

	
	
    file_r = filp_open(fileName, O_RDONLY, 0);
	if (IS_ERR(file_r)) 
	{
		DBGPRINT(RT_DEBUG_TRACE, ("-->1) %s: Error %ld opening %s\n", __FUNCTION__, -PTR_ERR(file_r), fileName));    
        return;
	}
	else 
	{
	    if (file_r->f_op && file_r->f_op->read) 
		{
		    char tempStr[64] = {0};            
            while ((rv = file_r->f_op->read(file_r, tempStr, 64, &file_r->f_pos)) > 0)
            {
                fileLen += rv;
            }
            cfgData = kmalloc(fileLen, MEM_ALLOC_FLAG);
            if (cfgData == NULL)
            {
                filp_close(file_r, NULL);
                DBGPRINT(RT_DEBUG_TRACE, ("CfgData kmalloc fail. (fileLen = %d)\n", fileLen));
                goto out;
            }
            NdisZeroMemory(cfgData, fileLen);
            file_r->f_pos = 0;
            rv = file_r->f_op->read(file_r, cfgData, fileLen, &file_r->f_pos);
            if (rv != fileLen)
            {
                filp_close(file_r, NULL);
                DBGPRINT(RT_DEBUG_TRACE, ("CfgData kmalloc fail, fileLen = %d\n", fileLen));
                goto ReadErr;
            }
        }
        filp_close(file_r, NULL);
    }

    file_w = filp_open(fileName, O_WRONLY|O_TRUNC, 0);
    if (IS_ERR(file_w)) 
	{
		DBGPRINT(RT_DEBUG_TRACE, ("-->2) %s: Error %ld opening %s\n", __FUNCTION__, -PTR_ERR(file_w), fileName));
        goto WriteFileOpenErr;
	}
	else 
	{
	    if (file_w->f_op && file_w->f_op->write) 
		{
            offset = rtstrstr(cfgData, "Default\n");
            offset += strlen("Default\n");
            file_w->f_op->write(file_w, cfgData, (size_t)(offset - cfgData), &file_w->f_pos);
            pTempStr = kmalloc(512, MEM_ALLOC_FLAG);
            if (!pTempStr)
            {
                DBGPRINT(RT_DEBUG_TRACE, ("pTempStr kmalloc fail. (512)\n"));
                filp_close(file_w, NULL);
                goto WriteErr;
            }
		    for (;;)
            {               
            	//HANK2008/6/23 10:16W 
                  int i = 0;
                char *ptr;
				NdisZeroMemory(pTempStr, 512);
				//sscanf(offset, "%s\n", pTempStr);
				ptr = offset;
                while(*ptr && *ptr != '\n')
                {
                    pTempStr[i++] = *ptr++;
                }
                pTempStr[i] = 0x00;
                //HANK2008/6/23 10:16W 
                
                if ((size_t)(offset - cfgData) < fileLen)
                {
                    offset += strlen(pTempStr) + 1;

                    if ((rtstrstr(pTempStr, "SSID=")||rtstrstr(pTempStr, "SSID1=")) && 
                        !rtstrstr(pTempStr, "NoForwardingBTNBSSID") && 
                        !rtstrstr(pTempStr, "HideSSID"))
                    {
                        //NdisZeroMemory(pTempStr, 512);
                        if (rtstrstr(pTempStr, "SSID="))
                            sprintf(pTempStr, "SSID=");
                        else
                            sprintf(pTempStr, "SSID1=");
#ifdef CONFIG_AP_SUPPORT
                        sprintf(pTempStr, "%s%s", pTempStr, pAd->ApCfg.MBSSID[MAIN_MBSSID].Ssid);
#endif // CONFIG_AP_SUPPORT //
                    }
                    else if (rtstrstr(pTempStr, "AuthMode=") &&
                             !rtstrstr(pTempStr, "ApCliAuthMode="))
                    {
                        NdisZeroMemory(pTempStr, 512);
                        sprintf(pTempStr, "AuthMode=");
#ifdef CONFIG_AP_SUPPORT
                        for (index = 0; index < MAX_MBSSID_NUM; index++)
                        {
                            if (pAd->ApCfg.MBSSID[index].SsidLen)
                            {
//                                USHORT auth_flag = WscGetAuthType(pAd->ApCfg.MBSSID[index].AuthMode);
                                if (index == 0)
                                    sprintf(pTempStr, "%s%s", pTempStr, WscGetRalinkAuthModeStr(pAd->ApCfg.MBSSID[index].AuthMode));
                                else
                                    sprintf(pTempStr, "%s;%s", pTempStr, WscGetRalinkAuthModeStr(pAd->ApCfg.MBSSID[index].AuthMode));
                            }
                        }
#endif // CONFIG_AP_SUPPORT //
                    }
                    else if (rtstrstr(pTempStr, "EncrypType=") &&
                             !rtstrstr(pTempStr, "WdsEncrypType") &&
                             !rtstrstr(pTempStr, "ApCliEncrypType"))
                    {
                        NdisZeroMemory(pTempStr, 512);
                        sprintf(pTempStr, "EncrypType=");
#ifdef CONFIG_AP_SUPPORT
                        for (index = 0; index < MAX_MBSSID_NUM; index++)
                        {
                            if (pAd->ApCfg.MBSSID[index].SsidLen)
                            {
                                //USHORT encrypt_flag = WscGetEncryType(pAd->ApCfg.MBSSID[index].WepStatus);
                                if (index == 0)
                                    sprintf(pTempStr, "%s%s", pTempStr, WscGetRalinkEncryModeStr(pAd->ApCfg.MBSSID[index].WepStatus));
                                else
                                    sprintf(pTempStr, "%s;%s", pTempStr, WscGetRalinkEncryModeStr(pAd->ApCfg.MBSSID[index].WepStatus));
                            }
                        }
#endif // CONFIG_AP_SUPPORT //
                    }
#ifdef CONFIG_AP_SUPPORT                    
                    else if ((rtstrstr(pTempStr, "WPAPSK=") || rtstrstr(pTempStr, "WPAPSK1=")) &&
                             !rtstrstr(pTempStr, "ApCliWPAPSK"))
#endif // CONFIG_AP_SUPPORT //
                    {
                        int offset = 0;
                        if (strstr(pTempStr, "WPAPSK1="))                            
                            offset = 8;
                        else
                            offset = 7;
#ifdef CONFIG_AP_SUPPORT                    
                        if (pAd->ApCfg.MBSSID[MAIN_MBSSID].AuthMode < Ndis802_11AuthModeWPA)
#endif // CONFIG_AP_SUPPORT //

                            goto next_item;
                        NdisZeroMemory(pTempStr, 512);
#ifdef CONFIG_AP_SUPPORT
                        if (offset == 8)
                            sprintf(pTempStr, "WPAPSK1=");
                        else
                            sprintf(pTempStr, "WPAPSK=");
#endif // CONFIG_AP_SUPPORT //
                        if (pWscControl->WpaPskLen >=8 &&
                            pWscControl->WpaPskLen <=64)
                            NdisMoveMemory(pTempStr+offset, pWscControl->WpaPsk, 
                                                       pWscControl->WpaPskLen);
                    }
                    else if (rtstrstr(pTempStr, "WscConfMode="))
                    {
                        NdisZeroMemory(pTempStr, 512);
                    	sprintf(pTempStr, "WscConfMode=%d", pWscControl->WscConfMode);
                    }
                    else if (rtstrstr(pTempStr, "WscConfStatus="))
                    {
                    	NdisZeroMemory(pTempStr, 512);
                    	sprintf(pTempStr, "WscConfStatus=%d", pWscControl->WscConfStatus);
                    }
                    else if (rtstrstr(pTempStr, "DefaultKeyID=") &&
                             !rtstrstr(pTempStr, "ApCliDefaultKeyID="))
                    {
                        NdisZeroMemory(pTempStr, 512);
#ifdef CONFIG_AP_SUPPORT
                    	sprintf(pTempStr, "DefaultKeyID=%d", pAd->ApCfg.MBSSID[apidx].DefaultKeyId+1);
#endif // CONFIG_AP_SUPPORT //
                    }
#ifdef CONFIG_AP_SUPPORT
                    else if (rtstrstr(pTempStr, WepKeyFormatName))
                    {
                        if (pAd->ApCfg.MBSSID[MAIN_MBSSID].WepStatus == Ndis802_11WEPEnabled)                           
                        {
                            NdisZeroMemory(pTempStr, 512);
                            if ((pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl.WscProfile.Profile[0].KeyLength == 5) || 
                                (pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl.WscProfile.Profile[0].KeyLength == 13))
                                sprintf(pTempStr, "%s1", WepKeyFormatName); // ASCII
                            else
                                sprintf(pTempStr, "%s0", WepKeyFormatName); // Hex
                        }
                    }
                    else if (rtstrstr(pTempStr, WepKeyName))
                    {
                        if (pAd->ApCfg.MBSSID[MAIN_MBSSID].WepStatus == Ndis802_11WEPEnabled)                           
                        {
                            NdisZeroMemory(pTempStr, 512);
                            sprintf(pTempStr, "%s", WepKeyName);
                            if ((pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl.WscProfile.Profile[0].KeyLength == 5) || 
                                (pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl.WscProfile.Profile[0].KeyLength == 13))
                            {
                                sprintf(pTempStr, "%s%s", pTempStr, pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl.WscProfile.Profile[0].Key);
                            }
                            else
                            {
                                int ii;
                                for (ii=0; ii<pAd->SharedKey[MAIN_MBSSID][pAd->ApCfg.MBSSID[MAIN_MBSSID].DefaultKeyId].KeyLen; ii++)
                                    sprintf(pTempStr, "%s%02X", pTempStr, 
                                                                pAd->SharedKey[MAIN_MBSSID][pAd->ApCfg.MBSSID[MAIN_MBSSID].DefaultKeyId].Key[ii]);
                            }
                        }
                    }
#endif // CONFIG_AP_SUPPORT //


next_item:                    
                    file_w->f_op->write(file_w, pTempStr, strlen(pTempStr), &file_w->f_pos);
                    file_w->f_op->write(file_w, "\n", 1, &file_w->f_pos);
                }
                else
                {
                    break;
                }
        }
    }
        filp_close(file_w, NULL);
    }
WriteErr:   
    if (pTempStr)
        kfree(pTempStr);
ReadErr:
WriteFileOpenErr:    
    if (cfgData)
        kfree(cfgData);    
out:
    set_fs(orgfs);
    current->fsuid = orgfsuid;
	current->fsgid = orgfsgid;
    

    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscWriteConfToDatFile\n"));
    return;
}

void start_write_dat_file_thread(
    IN  PRTMP_ADAPTER pAd)
{
    DBGPRINT(RT_DEBUG_TRACE, ("-----> start_write_dat_file_thread\n"));
    pAd->write_dat_file_pid = -1;
    pAd->time_to_die = 0;
    pAd->write_dat_file_pid = kernel_thread(write_dat_file_thread, pAd, CLONE_VM);
	if (pAd->write_dat_file_pid < 0) {
		printk (KERN_WARNING "unable to start kernel write dat file thread\n");
	}
    wait_for_completion (&pAd->write_dat_file_notify);
    DBGPRINT(RT_DEBUG_TRACE, ("<----- start_write_dat_file_thread\n"));
}

INT write_dat_file_thread (
    IN void *Context)
{
	PRTMP_ADAPTER   pAd = (PRTMP_ADAPTER)Context;
	int 	Status;
//	UCHAR			apidx = MAIN_MBSSID;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
    daemonize("rtmpWscHandle" /*"%s",pAd->net_dev->name*/);
#else
    daemonize();
#endif
	current->flags |= PF_NOFREEZE;
    /* signal that we've started the thread */
	complete(&(pAd->write_dat_file_notify));
#if 1    
	while (1) {
        /* lock the device pointers */
		Status = down_interruptible(&(pAd->write_dat_file_semaphore));
        
		if (pAd->time_to_die)
			break;


		if (Status != 0)
			continue;
				
        if (pAd->WriteWscCfgToDatFile)
        {
            WscWriteConfToDatFile(pAd);
            pAd->WriteWscCfgToDatFile = FALSE;
        }
	}
#endif
    complete_and_exit (&pAd->write_dat_file_notify, 0);
    return 0;
}

BOOLEAN WscCheckNonce(
	IN	PRTMP_ADAPTER	pAdapter, 
	IN	MLME_QUEUE_ELEM	*pElem,
	IN  BOOLEAN         bFlag,
	IN  PWSC_CTRL       pWscControl) 
{
    USHORT				Length;
	PUCHAR				pData;
	USHORT				WscType, WscLen, WscId;

    DBGPRINT(RT_DEBUG_TRACE, ("-----> WscCheckNonce\n"));
    
    if (bFlag)
    {
        // check Registrar Nonce
        WscId = WSC_ID_REGISTRAR_NONCE;
        DBGPRINT(RT_DEBUG_TRACE, ("check Registrar Nonce\n"));
    }
    else
    {
        // check Enrollee Nonce
        WscId = WSC_ID_ENROLLEE_NONCE;
        DBGPRINT(RT_DEBUG_TRACE, ("check Enrollee Nonce\n"));
    }
    
    pData = pElem->Msg;
    Length = pElem->MsgLen;

    // We have to look for WSC_IE_MSG_TYPE to classify M2 ~ M8, the remain size must large than 4
	while (Length > 4)
	{
		WSC_TLV_0B	TLV_Recv;
        char ZeroNonce[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
        
		memcpy((u8 *)&TLV_Recv, pData, 4);
		WscType = cpu2be16(TLV_Recv.tag);
		WscLen  = cpu2be16(TLV_Recv.len);
		pData  += 4;
		Length -= 4;
        
		if (WscType == WscId)
		{
			if (RTMPCompareMemory(pWscControl->RegData.SelfNonce, pData, 16) == 0)
			{
			    DBGPRINT(RT_DEBUG_TRACE, ("Nonce match!!\n"));
                DBGPRINT(RT_DEBUG_TRACE, ("<----- WscCheckNonce\n"));
				return TRUE;
			}
            else if (NdisEqualMemory(pData, ZeroNonce, 16))
            {
                // Intel external registrar will send WSC_NACK with enrollee nonce
                // "10 1A 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
                // when AP is configured and user selects not to configure AP.
                DBGPRINT(RT_DEBUG_TRACE, ("Zero Enrollee Nonce!!\n"));
                DBGPRINT(RT_DEBUG_TRACE, ("<----- WscCheckNonce\n"));
                return TRUE;
            }
		}
        
		// Offset to net WSC Ie
		pData  += WscLen;
		Length -= WscLen;
	}

    DBGPRINT(RT_DEBUG_TRACE, ("Nonce mismatch!!\n"));
    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscCheckNonce\n"));
    return FALSE;
}

VOID    WscGetRegDataPIN(
    IN  PRTMP_ADAPTER   pAdapter,
    IN  UINT            PinCode,
    IN  PWSC_CTRL       pWscControl)
{
	UCHAR	tempPIN[9] = {0};

    if (pWscControl->WscMode == 2)
        pWscControl->WscPinCode = 0;
    else
        pWscControl->WscPinCode = PinCode;

    memset(pWscControl->RegData.PIN, 0, 8);
	if (pWscControl->WscPinCode == 0)
		sprintf(tempPIN, "00000000");
	else
		sprintf(tempPIN, "%08u", pWscControl->WscPinCode);
	memcpy(pWscControl->RegData.PIN, tempPIN, 8);
}

VOID    WscEapActionDisabled(
    IN  PRTMP_ADAPTER       pAdapter,
    IN  PWSC_CTRL           pWscControl)
{
    INT     DataLen = 0;
    UCHAR   WscData[60] = {0};
    BOOLEAN Cancelled;
    
    pWscControl->RegData.EnrolleeInfo.ConfigError = WSC_ERROR_DEVICE_BUSY;
    DataLen = BuildMessageNACK(pAdapter, pWscControl, WscData);

#ifdef CONFIG_AP_SUPPORT
    if (pWscControl->EntryApIdx == MIN_NET_DEVICE_FOR_APCLI)
        WscSendMessage(pAdapter, WSC_OPCODE_NACK, WscData, DataLen, pWscControl, AP_CLIENT_MODE);
    else
        WscSendMessage(pAdapter, WSC_OPCODE_NACK, WscData, DataLen, pWscControl, AP_MODE);
#endif // CONFIG_AP_SUPPORT //


    RTMPCancelTimer(&pWscControl->EapolTimer, &Cancelled);
    pWscControl->EapolTimerRunning = FALSE;
}

VOID    WscGetConfigErrFromNack(
    IN  PRTMP_ADAPTER       pAdapter,
    IN	MLME_QUEUE_ELEM	    *pElem)
{
    USHORT				Length = 0;
	PUCHAR				pData;
	USHORT				WscType, WscLen, ConfigError = 0;

    pData = pElem->Msg;
    Length = pElem->MsgLen;
    
	while (Length > 4)
	{
		WSC_TLV_0B	TLV_Recv;
		memcpy((u8 *)&TLV_Recv, pData, 4);
		WscType = cpu2be16(TLV_Recv.tag);
		WscLen  = cpu2be16(TLV_Recv.len);
		pData  += 4;
		Length -= 4;
        
		if (WscType == WSC_ID_CONFIG_ERROR)
		{
			NdisMoveMemory(&ConfigError, pData, sizeof(USHORT));
		    DBGPRINT(RT_DEBUG_TRACE, ("WSC_ID_CONFIG_ERROR: %d\n", ntohs(ConfigError)));
			return;
		}
        
		// Offset to net WSC Ie
		pData  += WscLen;
		Length -= WscLen;
	}
    DBGPRINT(RT_DEBUG_TRACE, ("WSC_ID_CONFIG_ERROR is missing\n"));
}

#ifdef CONFIG_AP_SUPPORT
INT	WscSetAuthMode(
	IN	PRTMP_ADAPTER	pAd, 
	IN	PUCHAR			arg)
{
	UINT       i;
    UCHAR       apidx = MAIN_MBSSID;

    if ((strcmp(arg, "WEPAUTO") == 0) || (strcmp(arg, "wepauto") == 0))
		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeAutoSwitch;
	else if ((strcmp(arg, "OPEN") == 0) || (strcmp(arg, "open") == 0))
		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeOpen;
	else if ((strcmp(arg, "SHARED") == 0) || (strcmp(arg, "shared") == 0))
		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeShared;
	else if ((strcmp(arg, "WPAPSK") == 0) || (strcmp(arg, "wpapsk") == 0))
		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPAPSK;
	else if ((strcmp(arg, "WPA") == 0) || (strcmp(arg, "wpa") == 0))
		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA;
	else if ((strcmp(arg, "WPA2PSK") == 0) || (strcmp(arg, "wpa2psk") == 0))
		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA2PSK;
	else if ((strcmp(arg, "WPA2") == 0) || (strcmp(arg, "wpa2") == 0))
		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA2;
	else if ((strcmp(arg, "WPA1WPA2") == 0) || (strcmp(arg, "wpa1wpa2") == 0))
		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA1WPA2;
	else if ((strcmp(arg, "WPAPSKWPA2PSK") == 0) || (strcmp(arg, "wpapskwpa2psk") == 0))
		pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeWPA1PSKWPA2PSK;
    else
    {
        pAd->ApCfg.MBSSID[apidx].AuthMode = Ndis802_11AuthModeOpen;
        DBGPRINT(RT_DEBUG_TRACE, ("%s: Unknow AuthMode (%s), set AuthMode to OPEN\n", __FUNCTION__, arg));
    }

	for (i=0; i<MAX_LEN_OF_MAC_TABLE; i++)
	{
		if (pAd->MacTab.Content[i].ValidAsCLI)
		{
			pAd->MacTab.Content[i].PortSecured  = WPA_802_1X_PORT_NOT_SECURED;
		}
	}
	pAd->ApCfg.MBSSID[apidx].PortSecured = WPA_802_1X_PORT_NOT_SECURED;
    RTMPMakeRSNIE(pAd, pAd->ApCfg.MBSSID[apidx].AuthMode, pAd->ApCfg.MBSSID[apidx].WepStatus, apidx);

	pAd->ApCfg.MBSSID[apidx].DefaultKeyId  = 0;

	if(pAd->ApCfg.MBSSID[apidx].AuthMode >= Ndis802_11AuthModeWPA)
		pAd->ApCfg.MBSSID[apidx].DefaultKeyId = 0;

	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) %s::(AuthMode=%d)\n", apidx, __FUNCTION__, pAd->ApCfg.MBSSID[apidx].AuthMode));    

	return TRUE;
}

INT	WscSetEncrypType(
	IN	PRTMP_ADAPTER	pAd, 
	IN	PUCHAR			arg)
{
    UCHAR       apidx = MAIN_MBSSID;
    
    if ((strcmp(arg, "NONE") == 0) || (strcmp(arg, "none") == 0))
		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPDisabled;
	else if ((strcmp(arg, "WEP") == 0) || (strcmp(arg, "wep") == 0))
		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPEnabled;
	else if ((strcmp(arg, "TKIP") == 0) || (strcmp(arg, "tkip") == 0))
		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption2Enabled;
	else if ((strcmp(arg, "AES") == 0) || (strcmp(arg, "aes") == 0))
		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption3Enabled;
	else if ((strcmp(arg, "TKIPAES") == 0) || (strcmp(arg, "tkipaes") == 0))
		pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11Encryption4Enabled;
    else
    {
        pAd->ApCfg.MBSSID[apidx].WepStatus = Ndis802_11WEPDisabled;
        DBGPRINT(RT_DEBUG_TRACE, ("%s: Unknow EncrypType (%s), set EncrypType to NONE\n", __FUNCTION__, arg));
    }
    
    if (pAd->ApCfg.MBSSID[apidx].WepStatus >= Ndis802_11Encryption2Enabled)
		pAd->ApCfg.MBSSID[apidx].DefaultKeyId = 0;

    RTMPMakeRSNIE(pAd, pAd->ApCfg.MBSSID[apidx].AuthMode, pAd->ApCfg.MBSSID[apidx].WepStatus, apidx);
	DBGPRINT(RT_DEBUG_TRACE, ("IF(ra%d) %s::(EncrypType=%d)\n", apidx, __FUNCTION__, pAd->ApCfg.MBSSID[apidx].WepStatus));

	return TRUE;
}
#endif // CONFIG_AP_SUPPORT //

VOID	WscCreateProfileFromCfg(
	IN	PRTMP_ADAPTER		pAdapter,
	IN  UCHAR               OpMode,
	IN  PWSC_CTRL           pWscControl,
	OUT PWSC_PROFILE        pWscProfile)
{
    UCHAR	        apidx = MAIN_MBSSID;
    USHORT          authType = 0, encyType = 0;
    UCHAR           WepKeyId = 0;
    PWSC_CREDENTIAL pCredential = NULL;

#ifdef CONFIG_AP_SUPPORT
    if (OpMode == AP_MODE)
    {
        authType = WscGetAuthType(pAdapter->ApCfg.MBSSID[apidx].AuthMode);
        encyType = WscGetEncryType(pAdapter->ApCfg.MBSSID[apidx].WepStatus);
        WepKeyId = pAdapter->ApCfg.MBSSID[apidx].DefaultKeyId;
    }
#ifdef APCLI_SUPPORT    
    else if (OpMode == AP_CLIENT_MODE)
    {
        authType = WscGetAuthType(pAdapter->ApCfg.ApCliTab[apidx].AuthMode);
        encyType = WscGetEncryType(pAdapter->ApCfg.ApCliTab[apidx].WepStatus);
        WepKeyId = pAdapter->ApCfg.ApCliTab[apidx].DefaultKeyId;
    }
#endif // APCLI_SUPPORT //
#endif // CONFIG_AP_SUPPORT //

    DBGPRINT(RT_DEBUG_TRACE, ("-----> WscGetDefaultProfileForM8\n"));

    pCredential = &pWscProfile->Profile[0]; //Only support one credential now. 20070515
    NdisZeroMemory(pCredential, sizeof(WSC_CREDENTIAL));
    pWscProfile->ProfileCnt = 1;
    
#ifdef CONFIG_AP_SUPPORT
    // NewKey, NewKeyIndex for M8
	if((OpMode == AP_MODE) &&
       (WSC_SCSTATE_UNCONFIGURED == pWscControl->WscConfStatus))
	{
	    UCHAR   tempRandomByte = 0;
        UCHAR   idx = 0;
        NdisZeroMemory(pCredential->Key, 64);
		for (idx = 0; idx < 32; idx++)
		{
		    tempRandomByte = RandomByte(pAdapter);
            sprintf(pCredential->Key, "%s%02x", pCredential->Key, tempRandomByte);
		}
        pCredential->KeyLength = 64;
        pCredential->KeyIndex = 1;
        pCredential->AuthType = WSC_AUTHTYPE_WPA2PSK;
        pCredential->EncrType = WSC_ENCRTYPE_AES;
	}
    else
#endif // CONFIG_AP_SUPPORT //
    {
        pCredential->KeyIndex = 1;
        pCredential->KeyLength = 0;
        NdisZeroMemory(pCredential->Key, 64);
        switch (encyType)
        {
            case WSC_ENCRTYPE_NONE:
                break;
            case WSC_ENCRTYPE_WEP:
                pCredential->KeyIndex = (WepKeyId + 1);
                if ((OpMode == AP_MODE || OpMode == STA_MODE) && pAdapter->SharedKey[apidx][WepKeyId].KeyLen)
                {
                    int i;
                    for (i=0; i<pAdapter->SharedKey[apidx][WepKeyId].KeyLen; i++)
                        sprintf(pCredential->Key, "%s%02x", pCredential->Key, pAdapter->SharedKey[apidx][WepKeyId].Key[i]);
                    pCredential->KeyLength = pAdapter->SharedKey[apidx][WepKeyId].KeyLen*2;
                }
#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
                else if ((OpMode == AP_CLIENT_MODE) && pAdapter->ApCfg.ApCliTab[apidx].SharedKey[WepKeyId].KeyLen)
                {
                    int i;
                    for (i=0; i<pAdapter->ApCfg.ApCliTab[apidx].SharedKey[WepKeyId].KeyLen; i++)
                        sprintf(pCredential->Key, "%s%02x", pCredential->Key, pAdapter->ApCfg.ApCliTab[apidx].SharedKey[WepKeyId].Key[i]);
                    pCredential->KeyLength = pAdapter->SharedKey[apidx][WepKeyId].KeyLen*2;
                }
#endif // APCLI_SUPPORT //
#endif // CONFIG_AP_SUPPORT //
                break;
    		case WSC_ENCRTYPE_TKIP:
            case WSC_ENCRTYPE_AES:
                pCredential->KeyLength = pWscControl->WpaPskLen;
                memcpy(pCredential->Key, 
                       pWscControl->WpaPsk, 
                       pWscControl->WpaPskLen);
                break;
        }
        pCredential->AuthType = authType;
        pCredential->EncrType = encyType;
    }

#ifdef CONFIG_AP_SUPPORT
    if (OpMode == AP_MODE)
    {
        NdisMoveMemory(pCredential->MacAddr, pAdapter->ApCfg.MBSSID[apidx].Bssid, 6);
        NdisMoveMemory(pCredential->SSID.Ssid, pAdapter->ApCfg.MBSSID[apidx].Ssid, pAdapter->ApCfg.MBSSID[apidx].SsidLen);
        pCredential->SSID.SsidLength = pAdapter->ApCfg.MBSSID[apidx].SsidLen;
    }
#ifdef APCLI_SUPPORT    
    else if (OpMode == AP_CLIENT_MODE)
    {
        NdisMoveMemory(pCredential->MacAddr, APCLI_ROOT_BSSID_GET(pAdapter, pAdapter->ApCfg.ApCliTab[apidx].MacTabWCID), 6);
        NdisMoveMemory(pCredential->SSID.Ssid, pAdapter->ApCfg.ApCliTab[apidx].Ssid, pAdapter->ApCfg.ApCliTab[apidx].SsidLen);
        pCredential->SSID.SsidLength = pAdapter->ApCfg.ApCliTab[apidx].SsidLen;
    }
#endif // APCLI_SUPPORT //
    else
#endif // CONFIG_AP_SUPPORT //
    
    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscCreateProfileFromCfg\n"));

}

#ifdef CONFIG_AP_SUPPORT
#ifdef APCLI_SUPPORT
void    WscWriteConfToApCliCfg(
    IN  PRTMP_ADAPTER   pAd,
    IN  MAC_TABLE_ENTRY *pEntry,
    IN  BOOLEAN         bEnrollee)
{
    UCHAR               CurApIdx = BSS0;
    PWSC_PROFILE	    pProfile;
    PWSC_CTRL           pWscControl;

    DBGPRINT(RT_DEBUG_TRACE, ("-----> WscWriteConfToApCliCfg\n"));
    
    if (pEntry)
        CurApIdx = pEntry->apidx;

    pWscControl = &pAd->ApCfg.ApCliTab[CurApIdx].WscControl;

    {
        pProfile = (PWSC_PROFILE) &pWscControl->WscProfile;
        NdisZeroMemory(pAd->ApCfg.ApCliTab[CurApIdx].Ssid, MAX_LEN_OF_SSID);
    	NdisMoveMemory(pAd->ApCfg.ApCliTab[CurApIdx].Ssid, pProfile->Profile[0].SSID.Ssid, pProfile->Profile[0].SSID.SsidLength);
    	pAd->ApCfg.ApCliTab[CurApIdx].SsidLen = pProfile->Profile[0].SSID.SsidLength;

        NdisZeroMemory(pAd->ApCfg.ApCliTab[CurApIdx].CfgSsid, MAX_LEN_OF_SSID);
    	NdisMoveMemory(pAd->ApCfg.ApCliTab[CurApIdx].CfgSsid, pProfile->Profile[0].SSID.Ssid, pProfile->Profile[0].SSID.SsidLength);
    	pAd->ApCfg.ApCliTab[CurApIdx].CfgSsidLen = pProfile->Profile[0].SSID.SsidLength;

        DBGPRINT(RT_DEBUG_TRACE, ("AuthType: %d, EncrType: %d\n", pProfile->Profile[0].AuthType, pProfile->Profile[0].EncrType));
        if ((pProfile->Profile[0].AuthType == WSC_AUTHTYPE_WPAPSK) || 
            (pProfile->Profile[0].AuthType == WSC_AUTHTYPE_WPA2PSK))
        {
            if ((pProfile->Profile[0].EncrType != WSC_ENCRTYPE_TKIP) && (pProfile->Profile[0].EncrType != WSC_ENCRTYPE_AES))
            {
                DBGPRINT(RT_DEBUG_TRACE, ("AuthType is WPAPSK or WPA2PAK.\n"
                                         "Get illegal EncrType(%d) from External Registrar, set EncrType to TKIP\n", 
                                          pProfile->Profile[0].EncrType));
                pProfile->Profile[0].EncrType = WSC_ENCRTYPE_TKIP;
            }
        }
        Set_ApCli_AuthMode_Proc(pAd, WscGetAuthTypeStr(pProfile->Profile[0].AuthType));
        Set_ApCli_EncrypType_Proc(pAd, WscGetEncryTypeStr(pProfile->Profile[0].EncrType));
        if (pProfile->Profile[0].EncrType != WSC_ENCRTYPE_NONE)
        {
            if ((pProfile->Profile[0].EncrType == WSC_ENCRTYPE_TKIP) ||
                (pProfile->Profile[0].EncrType == WSC_ENCRTYPE_AES))
            {
                pAd->ApCfg.ApCliTab[CurApIdx].DefaultKeyId = 0;

                if (pProfile->Profile[0].KeyLength >= 8 && pProfile->Profile[0].KeyLength <= 64)
                {
                    pWscControl->WpaPskLen = pProfile->Profile[0].KeyLength;
                    memset(pWscControl->WpaPsk, 0, 64);
                    memcpy(pWscControl->WpaPsk, pProfile->Profile[0].Key, pWscControl->WpaPskLen);

                    if (pWscControl->WpaPskLen == 64)
                	{
                	    AtoH(pWscControl->WpaPsk, pAd->ApCfg.ApCliTab[CurApIdx].PMK, 32);
                	}
                	else
                	{
                	    UCHAR       keyMaterial[40] = {0};
                	    PasswordHash((CHAR *)pWscControl->WpaPsk, 
                                     pAd->ApCfg.ApCliTab[CurApIdx].Ssid, pAd->ApCfg.ApCliTab[CurApIdx].SsidLen, keyMaterial);
                	    NdisMoveMemory(pAd->ApCfg.ApCliTab[CurApIdx].PMK, keyMaterial, 32);

                	}
                    DBGPRINT(RT_DEBUG_TRACE, ("WpaPskLen = %d\n", pWscControl->WpaPskLen));
                }
                else
                {
                    pWscControl->WpaPskLen = 0;
                    DBGPRINT(RT_DEBUG_TRACE, ("WPAPSK: Invalid Key Length (%d)\n", pProfile->Profile[0].KeyLength));
                }
            }
            else if (pProfile->Profile[0].EncrType == WSC_ENCRTYPE_WEP)
            {
                CHAR   WepKeyId = 0;
                USHORT  WepKeyLen = pProfile->Profile[0].KeyLength;

				WepKeyId = (pProfile->Profile[0].KeyIndex - 1); // KeyIndex = 1 ~ 4
                if ((WepKeyId >= 0) && (WepKeyId <=3))
                {
                    pAd->ApCfg.ApCliTab[CurApIdx].DefaultKeyId = WepKeyId;

                    // 5 or 13 ASCII characters
                    // 10 or 26 Hex characters
                    if (WepKeyLen == 5 || WepKeyLen == 13 || WepKeyLen == 10 || WepKeyLen == 26)
                    {
                        if (WepKeyLen == 5 || WepKeyLen == 13)
                        {
                            pAd->ApCfg.ApCliTab[CurApIdx].SharedKey[WepKeyId].KeyLen = WepKeyLen;
                            memcpy(pAd->ApCfg.ApCliTab[CurApIdx].SharedKey[WepKeyId].Key, 
                                   pProfile->Profile[0].Key,
                                   WepKeyLen);
                            if (WepKeyLen == 5)
                                pAd->ApCfg.ApCliTab[CurApIdx].SharedKey[WepKeyId].CipherAlg = CIPHER_WEP64;
                            else
                                pAd->ApCfg.ApCliTab[CurApIdx].SharedKey[WepKeyId].CipherAlg = CIPHER_WEP128;
                        }
                        else
                        {
                            pAd->ApCfg.ApCliTab[CurApIdx].SharedKey[WepKeyId].KeyLen = WepKeyLen/2;
                            AtoH(pProfile->Profile[0].Key, pAd->ApCfg.ApCliTab[CurApIdx].SharedKey[WepKeyId].Key, WepKeyLen/2);
                            if (WepKeyLen == 10)
                                pAd->ApCfg.ApCliTab[CurApIdx].SharedKey[WepKeyId].CipherAlg = CIPHER_WEP64;
                            else
                                pAd->ApCfg.ApCliTab[CurApIdx].SharedKey[WepKeyId].CipherAlg = CIPHER_WEP128;
                        }
                    }
                    else
                        DBGPRINT(RT_DEBUG_TRACE, ("WEP: Invalid Key Length (%d)\n", pProfile->Profile[0].KeyLength));
                }
                else
               	{
               		DBGPRINT(RT_DEBUG_TRACE, ("Unsupport default key index (%d), use key Index 1.\n", WepKeyId));
               		pAd->ApCfg.ApCliTab[CurApIdx].DefaultKeyId = WepKeyId = 0;
                }
            }
        }
    }

    DBGPRINT(RT_DEBUG_TRACE, ("<----- WscWriteConfToApCliCfg\n"));
}
#endif // APCLI_SUPPORT //
#endif // CONFIG_AP_SUPPORT //

#ifdef CONFIG_AP_SUPPORT
VOID   WpsApSmProcess(
    IN PRTMP_ADAPTER        pAd,
    IN MLME_QUEUE_ELEM 	   *Elem)
{
    int                 HeaderLen = LENGTH_802_11 + LENGTH_802_1_H + sizeof(IEEE8021X_FRAME) + sizeof(EAP_FRAME);
    PHEADER_802_11      pHeader;
	PMAC_TABLE_ENTRY    pEntry = NULL;
	int                 apidx = MAIN_MBSSID;
	
    pHeader = (PHEADER_802_11)Elem->Msg;
    
    if (Elem->MsgType == WSC_EAPOL_PACKET_MSG)
    {
		if ((pEntry = MacTableLookup(pAd, pHeader->Addr2)))
            apidx = pEntry->apidx;
    }
	
	if((Elem->MsgType == WSC_EAPOL_UPNP_MSG) && (Elem->MsgLen > HeaderLen))
	{	//The WSC msg from UPnP daemon
		PUCHAR		pData;
		UCHAR 		MacAddr[MAC_ADDR_LEN]= {0};
		
		DBGPRINT(RT_DEBUG_INFO, ("Receive a UPnP WSC Message!\n"));
        // Skip the (802.11 + 802.1h + 802.1x + EAP) header
    	pData = (PUCHAR) &Elem->Msg[HeaderLen];
        Elem->MsgLen -= HeaderLen;
		// The Addr1 of UPnP-Msg used to indicate the MAC address of the AP interface. Now always be ra0.
		NdisMoveMemory(MacAddr, pHeader->Addr1, MAC_ADDR_LEN);
		NdisMoveMemory(Elem->Msg, MacAddr, MAC_ADDR_LEN);
		NdisMoveMemory(Elem->Msg+6, pData, Elem->MsgLen);
		
		StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem);
	}
    else if (pEntry && (Elem->MsgType == WSC_EAPOL_PACKET_MSG) && 
			 (
			     (pEntry->ValidAsCLI && MAC_ADDR_EQUAL(pHeader->Addr2, pAd->ApCfg.MBSSID[apidx].WscControl.EntryAddr))
#ifdef APCLI_SUPPORT
			   ||(pEntry->ValidAsApCli && MAC_ADDR_EQUAL(pHeader->Addr2, pAd->ApCfg.ApCliTab[apidx].WscControl.EntryAddr))
#endif // APCLI_SUPPORT //
			 )
			)
    {   // WSC_STATE_MACHINE can service only one station at one time
        PUCHAR		pData;
        PEAP_FRAME  pEapFrame;
        // Skip the EAP LLC header
    	pData = (PUCHAR) &Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
        pEapFrame = (PEAP_FRAME)(pData + sizeof(IEEE8021X_FRAME));
    	pData += sizeof(IEEE8021X_FRAME) + sizeof(EAP_FRAME);

#ifdef APCLI_SUPPORT
        if (pEntry->ValidAsApCli)
        {
            pAd->ApCfg.ApCliTab[apidx].WscControl.lastId = pEapFrame->Id;
            if (pEapFrame->Code == EAP_CODE_FAIL)
            { // EAP-Fail
                UCHAR	fail_data[] = "EAP_FAIL";
                NdisMoveMemory(Elem->Msg, pHeader->Addr2, MAC_ADDR_LEN);
                NdisMoveMemory(Elem->Msg+6, fail_data, strlen(fail_data));
                Elem->MsgLen = strlen(fail_data);
                StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem);
                return;
            }
            else if ((pEapFrame->Code == EAP_CODE_REQ) && (pEapFrame->Type == EAP_TYPE_ID))
            { // EAP-Req (Identity)
                UCHAR	id_data[] = "hello";
                NdisMoveMemory(Elem->Msg, pHeader->Addr2, MAC_ADDR_LEN);
                NdisMoveMemory(Elem->Msg+6, id_data, strlen(id_data));
                Elem->MsgLen = strlen(id_data);
                StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem);
                return;
            }
        }
#endif // APCLI_SUPPORT //     
        if (Elem->MsgLen <= HeaderLen)
        {
            DBGPRINT(RT_DEBUG_ERROR, ("Elem->MsgLen(%ld) <= HeaderLen(%d) !!\n", Elem->MsgLen, HeaderLen));
            return;
        }
        
        Elem->MsgLen -= (LENGTH_802_11 + LENGTH_802_1_H + sizeof(IEEE8021X_FRAME) + sizeof(EAP_FRAME));
        NdisMoveMemory(Elem->Msg, pHeader->Addr2, MAC_ADDR_LEN);
        if ((pEntry->ValidAsCLI) &&
            (pEapFrame->Code == EAP_CODE_RSP) && 
            (pEapFrame->Type == EAP_TYPE_ID))
        { 
            if (strstr(pData, "SimpleConfig"))
            // EAP-Rsp (Identity)
            NdisMoveMemory(Elem->Msg+6, pData, Elem->MsgLen);
            else
            {
                BOOLEAN Cancelled;
                DBGPRINT(RT_DEBUG_TRACE, ("RTMPCancelTimer EapolTimer!!\n"));
                pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl.EapolTimerRunning = FALSE;
                pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryApIdx = WSC_INIT_ENTRY_APIDX;
                NdisZeroMemory(pAd->ApCfg.MBSSID[pEntry->apidx].WscControl.EntryAddr, MAC_ADDR_LEN);
                RTMPCancelTimer(&pAd->ApCfg.MBSSID[MAIN_MBSSID].WscControl.EapolTimer, &Cancelled);
                return;
            }
        }
        else
        {
            if (WscCheckWSCHeader(pAd, pData))
            {
#ifdef APCLI_SUPPORT
                if ((pEntry->ValidAsApCli) &&
                    (pEapFrame->Code == EAP_CODE_REQ) && 
                    (pEapFrame->Type == EAP_TYPE_WSC))
                {
                    PWSC_FRAME			pWsc = (PWSC_FRAME) pData;
                    if (pWsc->OpCode == WSC_OPCODE_START)
                    {
                        UCHAR	wsc_start[] = "WSC_START";
                        NdisMoveMemory(Elem->Msg+6, wsc_start, strlen(wsc_start));
                        Elem->MsgLen = strlen(wsc_start);
                    }
                    else
                    {
                        pData += sizeof(WSC_FRAME);
                        Elem->MsgLen -= sizeof(WSC_FRAME);
                        NdisMoveMemory(Elem->Msg+6, pData, Elem->MsgLen);
                    }
                }
                else
#endif // APCLI_SUPPORT //
                {
                    // EAP-Rsp (Messages)
                pData += sizeof(WSC_FRAME);
                Elem->MsgLen -= sizeof(WSC_FRAME);
                NdisMoveMemory(Elem->Msg+6, pData, Elem->MsgLen);
            }
            }
            else
            {
                DBGPRINT(RT_DEBUG_TRACE, ("ERROR: WscCheckWSCHeader() return FALSE!\n"));
                return;
            }
        }
        StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem);
    }
    else if (Elem->MsgType == WSC_EAPOL_START_MSG)
        StateMachinePerformAction(pAd, &pAd->Mlme.WscMachine, Elem);
}
#endif // CONFIG_AP_SUPPORT //


